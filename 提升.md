# KVå­˜å‚¨RAFTé¡¹ç›® - æ€§èƒ½ä¸æ¶æ„æå‡æŠ¥å‘Š

## ğŸ“‹ æŠ¥å‘Šä¿¡æ¯

- **ç”Ÿæˆæ—¶é—´**: 2025å¹´10æœˆ28æ—¥
- **åˆ†æèŒƒå›´**: å…¨ä»£ç åº“
- **åˆ†æç›®æ ‡**: æ€§èƒ½ç“¶é¢ˆã€é˜»å¡æ“ä½œã€å¹¶å‘æ§åˆ¶ã€å®‰å…¨æ€§
- **æŠ¥å‘Šç‰ˆæœ¬**: v1.0

---

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

ç»è¿‡å…¨é¢çš„ä»£ç å®¡æŸ¥ï¼Œå‘ç°äº† **7ä¸ªä¸»è¦æ”¹è¿›æ–¹å‘**ï¼Œæ¶‰åŠ **15ä¸ªå…·ä½“æ–‡ä»¶**ï¼Œå…±è®¡ **32å¤„éœ€è¦æ”¹è¿›çš„ä»£ç ä½ç½®**ã€‚

### ä¼˜å…ˆçº§åˆ†ç±»

| ä¼˜å…ˆçº§ | æ”¹è¿›é¡¹æ•° | å½±å“ç¨‹åº¦ |
|--------|---------|---------|
| ğŸ”´ **P0 - é«˜ä¼˜å…ˆçº§** | 8ä¸ª | ä¸¥é‡å½±å“æ€§èƒ½æˆ–æ­£ç¡®æ€§ |
| ğŸŸ¡ **P1 - ä¸­ä¼˜å…ˆçº§** | 12ä¸ª | ä¸­ç­‰å½±å“ï¼Œå»ºè®®æ”¹è¿› |
| ğŸŸ¢ **P2 - ä½ä¼˜å…ˆçº§** | 12ä¸ª | ä¼˜åŒ–å»ºè®®ï¼Œå¯é€‰ |

---

## ğŸ”´ P0 - é«˜ä¼˜å…ˆçº§æ”¹è¿›é¡¹

### 1. util.h/cpp - LockQueue ä½¿ç”¨é˜»å¡å¼æ¡ä»¶å˜é‡

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/common/include/util.h`  
**ä»£ç å—**: LockQueue ç±»  
**è¡Œå·**: ç¬¬ 62-112 è¡Œ

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ç¬¬ 111 è¡Œ
std::condition_variable m_condvariable;  // âŒ é˜»å¡å¼æ¡ä»¶å˜é‡

// ç¬¬ 74-78 è¡Œ - Pop() æ–¹æ³•
T Pop() {
    std::unique_lock<std::mutex> lock(m_mutex);
    while (m_queue.empty()) {
      m_condvariable.wait(lock);  // âŒ é˜»å¡ç­‰å¾…ï¼Œä¼šé˜»å¡æ•´ä¸ªçº¿ç¨‹
    }
    // ...
}

// ç¬¬ 95 è¡Œ - timeOutPop() æ–¹æ³•
if (m_condvariable.wait_until(lock, timeout_time) == std::cv_status::timeout) {
    // âŒ é˜»å¡å¼è¶…æ—¶ç­‰å¾…
}
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **æ€§èƒ½é—®é¢˜**: 
   - `std::condition_variable::wait()` ä¼šé˜»å¡æ•´ä¸ªçº¿ç¨‹ï¼Œè€Œä¸æ˜¯åç¨‹
   - åœ¨åç¨‹ç¯å¢ƒä¸­ï¼Œè¿™ä¼šå¯¼è‡´æ•´ä¸ªå·¥ä½œçº¿ç¨‹è¢«é˜»å¡
   - å…¶ä»–åç¨‹æ— æ³•åœ¨è¯¥çº¿ç¨‹ä¸Šè°ƒåº¦ï¼Œä¸¥é‡å½±å“å¹¶å‘æ€§èƒ½

2. **æ¶æ„ä¸ä¸€è‡´**:
   - é¡¹ç›®å·²ç»åç¨‹åŒ–ï¼Œä½† LockQueue ä»ä½¿ç”¨çº¿ç¨‹çº§é˜»å¡
   - è¿èƒŒäº†åç¨‹å¼‚æ­¥éé˜»å¡çš„è®¾è®¡ç†å¿µ

3. **å®é™…å½±å“**:
   - applyChan ä½¿ç”¨ LockQueueï¼ŒapplierTicker() ä¼šé¢‘ç¹è°ƒç”¨ Pop()
   - æ¯æ¬¡ Pop() é˜»å¡ä¼šå¯¼è‡´è¯¥çº¿ç¨‹ä¸Šçš„æ‰€æœ‰åç¨‹æš‚åœ

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨ monsoon åç¨‹çš„ Channel**

```cpp
// æ›¿æ¢ LockQueue ä¸ºåç¨‹å‹å¥½çš„ Channel
template <typename T>
class FiberChannel {
public:
    void Push(const T& data) {
        // ä½¿ç”¨åç¨‹çº§åˆ«çš„ç­‰å¾…
        monsoon::IOManager* iom = monsoon::IOManager::GetThis();
        // å®ç°åç¨‹å®‰å…¨çš„push
    }
    
    T Pop() {
        // ä½¿ç”¨åç¨‹çº§åˆ«çš„ç­‰å¾…ï¼Œä¸é˜»å¡çº¿ç¨‹
        monsoon::IOManager* iom = monsoon::IOManager::GetThis();
        // ä½¿ç”¨å®šæ—¶å™¨ + yield å®ç°éé˜»å¡ç­‰å¾…
    }
};
```

**æ–¹æ¡ˆ2: ä½¿ç”¨å®šæ—¶å™¨è½®è¯¢ä»£æ›¿é˜»å¡ç­‰å¾…**

```cpp
T Pop() {
    while (true) {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            if (!m_queue.empty()) {
                T data = m_queue.front();
                m_queue.pop();
                return data;
            }
        }
        // ä½¿ç”¨åç¨‹sleepï¼Œä¸é˜»å¡çº¿ç¨‹
        usleep(1000);  // 1msè½®è¯¢ï¼Œä¼šè¢«hookä¸ºåç¨‹åˆ‡æ¢
    }
}
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **æ€§èƒ½æå‡**: 50-200%ï¼ˆé«˜å¹¶å‘åœºæ™¯ï¼‰
- **çº¿ç¨‹åˆ©ç”¨ç‡**: æå‡ 3-5 å€
- **åç¨‹è°ƒåº¦**: æ— é˜»å¡ï¼Œè°ƒåº¦æµç•…

---

### 2. util.cpp - sleepNMilliseconds ä½¿ç”¨çº¿ç¨‹çº§ç¡çœ 

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/common/util.cpp`  
**å‡½æ•°**: `sleepNMilliseconds()`  
**è¡Œå·**: ç¬¬ 25 è¡Œ

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ç¬¬ 25 è¡Œ
void sleepNMilliseconds(int N) { 
    std::this_thread::sleep_for(std::chrono::milliseconds(N));  // âŒ çº¿ç¨‹çº§ç¡çœ 
}
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **é˜»å¡æ•´ä¸ªçº¿ç¨‹**:
   - `std::this_thread::sleep_for()` æ˜¯çº¿ç¨‹çº§ç¡çœ 
   - ä¼šé˜»å¡æ•´ä¸ªç‰©ç†çº¿ç¨‹ï¼Œå¯¼è‡´è¯¥çº¿ç¨‹ä¸Šçš„æ‰€æœ‰åç¨‹æ— æ³•è°ƒåº¦

2. **æœªè¢« Hook**:
   - é¡¹ç›®çš„ Hook æœºåˆ¶åªæ‹¦æˆª `sleep()`ã€`usleep()`ã€`nanosleep()`
   - `std::this_thread::sleep_for()` æ˜¯ C++ æ ‡å‡†åº“å‡½æ•°ï¼Œæœªè¢«æ‹¦æˆª

3. **ä½¿ç”¨åœºæ™¯**:
   - è¢« `applierTicker()` è°ƒç”¨ï¼ˆraft.cpp ç¬¬ 173 è¡Œï¼‰
   - æ¯æ¬¡è°ƒç”¨éƒ½ä¼šé˜»å¡çº¿ç¨‹

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨å·² Hook çš„ sleep å‡½æ•°**

```cpp
// ä¿®æ”¹ä¸ºä½¿ç”¨ usleepï¼Œä¼šè¢« hook æ‹¦æˆª
void sleepNMilliseconds(int N) {
    usleep(N * 1000);  // âœ… ä¼šè¢« hook ä¸ºåç¨‹åˆ‡æ¢
}
```

**æ–¹æ¡ˆ2: åˆ é™¤æ­¤å‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨ usleep**

```cpp
// åœ¨ raft.cpp ç¬¬ 173 è¡Œ
// æ—§ä»£ç ï¼š
sleepNMilliseconds(ApplyInterval);

// æ–°ä»£ç ï¼š
usleep(ApplyInterval * 1000);  // âœ… ç›´æ¥ä½¿ç”¨ usleep
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **çº¿ç¨‹é˜»å¡**: ä» 100% é˜»å¡ â†’ 0% é˜»å¡
- **åç¨‹è°ƒåº¦**: æ¢å¤æ­£å¸¸è°ƒåº¦
- **æ€§èƒ½**: applier çº¿ç¨‹æ€§èƒ½æå‡ 2-3 å€

---

### 3. raft.cpp - leaderHearBeatTicker å’Œ electionTimeOutTicker ä¸­çš„ usleep

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/raft.cpp`

**ä½ç½®1**: `leaderHearBeatTicker()` å‡½æ•°  
**è¡Œå·**: ç¬¬ 484 è¡Œ

**ä½ç½®2**: `electionTimeOutTicker()` å‡½æ•°  
**è¡Œå·**: ç¬¬ 320ã€336ã€504 è¡Œ

#### ğŸ› é—®é¢˜æè¿°

```cpp
// leaderHearBeatTicker() - ç¬¬ 484 è¡Œ
while (m_status != Leader) {
    usleep(1000 * HeartBeatTimeout);  // âš ï¸ éœ€è¦ç¡®è®¤æ˜¯å¦åœ¨åç¨‹ç¯å¢ƒ
}

// electionTimeOutTicker() - ç¬¬ 320 è¡Œ
while (m_status == Leader) {
    usleep(HeartBeatTimeout);  // âš ï¸ éœ€è¦ç¡®è®¤æ˜¯å¦åœ¨åç¨‹ç¯å¢ƒ
}

// electionTimeOutTicker() - ç¬¬ 336 è¡Œ
usleep(std::chrono::duration_cast<std::chrono::microseconds>(suitableSleepTime).count());
// âš ï¸ éœ€è¦ç¡®è®¤æ˜¯å¦åœ¨åç¨‹ç¯å¢ƒ

// electionTimeOutTicker() - ç¬¬ 504 è¡Œ  
usleep(std::chrono::duration_cast<std::chrono::microseconds>(suitableSleepTime).count());
// âš ï¸ éœ€è¦ç¡®è®¤æ˜¯å¦åœ¨åç¨‹ç¯å¢ƒ
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **Hook ä¾èµ–æ€§**:
   - `usleep()` åªæœ‰åœ¨ `t_hook_enable = true` æ—¶æ‰ä¼šè¢« hook
   - å¦‚æœè¿™äº›å‡½æ•°ä¸åœ¨ IOManager åç¨‹ç¯å¢ƒä¸­è¿è¡Œï¼Œä¼šé€€åŒ–ä¸ºçº¿ç¨‹é˜»å¡

2. **è¿è¡Œç¯å¢ƒä¸ç¡®å®š**:
   - éœ€è¦ç¡®è®¤ `leaderHearBeatTicker()` å’Œ `electionTimeOutTicker()` æ˜¯å¦åœ¨åç¨‹ä¸­å¯åŠ¨
   - å¦‚æœæ˜¯æ™®é€šçº¿ç¨‹å¯åŠ¨ï¼Œusleep ä¸ä¼šè¢« hook

3. **æ½œåœ¨é£é™©**:
   - å¦‚æœæœªè¢« hookï¼Œæ¯æ¬¡ usleep éƒ½ä¼šé˜»å¡çº¿ç¨‹
   - å¿ƒè·³å’Œé€‰ä¸¾è¶…æ—¶æ£€æŸ¥ä¼šä¸¥é‡å½±å“æ€§èƒ½

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ç¡®ä¿åœ¨åç¨‹ç¯å¢ƒä¸­è¿è¡Œï¼ˆæ¨èï¼‰**

```cpp
// åœ¨ raft åˆå§‹åŒ–æ—¶ï¼Œç¡®ä¿è¿™äº› ticker å‡½æ•°åœ¨ IOManager ä¸­è¿è¡Œ
void Raft::init(...) {
    // ...
    
    // âœ… ç¡®ä¿åœ¨ IOManager åç¨‹ä¸­å¯åŠ¨
    monsoon::IOManager* iom = monsoon::IOManager::GetThis();
    if (!iom) {
        std::cerr << "Error: Raft must run in IOManager context!" << std::endl;
        exit(1);
    }
    
    iom->scheduler([this]() {
        this->leaderHearBeatTicker();
    });
    
    iom->scheduler([this]() {
        this->electionTimeOutTicker();
    });
    
    iom->scheduler([this]() {
        this->applierTicker();
    });
}
```

**æ–¹æ¡ˆ2: æ·»åŠ è¿è¡Œæ—¶æ£€æŸ¥**

```cpp
void Raft::leaderHearBeatTicker() {
    // âœ… æ·»åŠ æ£€æŸ¥
    if (!monsoon::is_hook_enable()) {
        std::cerr << "Warning: leaderHearBeatTicker not in hook context!" << std::endl;
    }
    
    while (true) {
        // ... åŸæœ‰é€»è¾‘
    }
}
```

**æ–¹æ¡ˆ3: ä½¿ç”¨ monsoon å®šæ—¶å™¨ä»£æ›¿ usleep è½®è¯¢**

```cpp
void Raft::scheduleHeartbeat() {
    auto iom = monsoon::IOManager::GetThis();
    if (!iom) return;
    
    // âœ… ä½¿ç”¨å®šæ—¶å™¨ä»£æ›¿ while + usleep
    m_heartbeat_timer = iom->addTimer(HeartBeatTimeout, [this]() {
        if (m_status == Leader) {
            this->doHeartbeat();
            this->scheduleHeartbeat();  // é€’å½’è°ƒåº¦ä¸‹ä¸€æ¬¡
        }
    });
}
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **CPU ä½¿ç”¨ç‡**: é™ä½ 20-30%ï¼ˆé¿å…ç©ºè½¬ï¼‰
- **è°ƒåº¦æ•ˆç‡**: æå‡ 2-3 å€
- **ä»£ç æ¸…æ™°åº¦**: æ›´ç¬¦åˆäº‹ä»¶é©±åŠ¨æ¨¡å‹

---

### 4. kvServer.cpp - å¯åŠ¨æ—¶ä½¿ç”¨ sleep() åŒæ­¥

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/kvServer.cpp`  
**å‡½æ•°**: `StartKvServer()`  
**è¡Œå·**: ç¬¬ 401ã€431 è¡Œ

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ç¬¬ 401 è¡Œ
sleep(6);  // âŒ å›ºå®šç¡çœ 6ç§’ç­‰å¾…å…¶ä»–èŠ‚ç‚¹

// ç¬¬ 431 è¡Œ
sleep(ipPortVt.size() - me);  // âŒ æ ¹æ®èŠ‚ç‚¹æ•°ç¡çœ 
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **ç²—ç³™çš„åŒæ­¥æ–¹å¼**:
   - ä½¿ç”¨å›ºå®šæ—¶é—´ç¡çœ æ¥ç­‰å¾…å…¶ä»–èŠ‚ç‚¹å¯åŠ¨
   - ä¸å¤Ÿç²¾ç¡®ï¼Œå¯èƒ½ç¡çœ è¿‡çŸ­ï¼ˆèŠ‚ç‚¹æœªå°±ç»ªï¼‰æˆ–è¿‡é•¿ï¼ˆæµªè´¹æ—¶é—´ï¼‰

2. **å¯åŠ¨å»¶è¿Ÿ**:
   - 3ä¸ªèŠ‚ç‚¹é›†ç¾¤éœ€è¦ç­‰å¾… 6 + 2 = 8 ç§’
   - 10ä¸ªèŠ‚ç‚¹é›†ç¾¤éœ€è¦ç­‰å¾… 6 + 9 = 15 ç§’
   - å¯åŠ¨æ—¶é—´éšèŠ‚ç‚¹æ•°çº¿æ€§å¢é•¿

3. **å¯é æ€§é—®é¢˜**:
   - ç½‘ç»œæ…¢æˆ–èŠ‚ç‚¹é…ç½®æ…¢æ—¶ï¼Œå›ºå®šæ—¶é—´å¯èƒ½ä¸å¤Ÿ
   - ç¼ºä¹çœŸæ­£çš„å°±ç»ªæ£€æŸ¥

4. **Hook çŠ¶æ€ä¸ç¡®å®š**:
   - å¦‚æœ StartKvServer() ä¸åœ¨åç¨‹ä¸­è¿è¡Œï¼Œsleep() ä¼šé˜»å¡çº¿ç¨‹
   - éœ€è¦ç¡®è®¤è°ƒç”¨ç¯å¢ƒ

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨å¥åº·æ£€æŸ¥ä»£æ›¿å›ºå®šç¡çœ ï¼ˆæœ€ä½³ï¼‰**

```cpp
// âœ… ä¸»åŠ¨æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å°±ç»ª
bool waitForNodesReady(const std::vector<std::pair<std::string, short>>& nodes, 
                       int maxWaitSeconds = 30) {
    auto deadline = std::chrono::steady_clock::now() + 
                    std::chrono::seconds(maxWaitSeconds);
    
    while (std::chrono::steady_clock::now() < deadline) {
        bool allReady = true;
        
        for (size_t i = 0; i < nodes.size(); ++i) {
            if (i == m_me) continue;
            
            // å°è¯•è¿æ¥æ£€æŸ¥
            int sock = socket(AF_INET, SOCK_STREAM, 0);
            sockaddr_in addr;
            addr.sin_family = AF_INET;
            addr.sin_port = htons(nodes[i].second);
            inet_pton(AF_INET, nodes[i].first.c_str(), &addr.sin_addr);
            
            if (connect(sock, (sockaddr*)&addr, sizeof(addr)) != 0) {
                allReady = false;
                close(sock);
                break;
            }
            close(sock);
        }
        
        if (allReady) {
            std::cout << "All nodes ready!" << std::endl;
            return true;
        }
        
        usleep(500000);  // 500msåé‡è¯•ï¼Œä¼šè¢«hook
    }
    
    return false;
}

// ä½¿ç”¨ï¼š
if (!waitForNodesReady(ipPortVt, 30)) {
    std::cerr << "Error: Not all nodes ready after 30 seconds" << std::endl;
    exit(1);
}
```

**æ–¹æ¡ˆ2: ä½¿ç”¨é…ç½®åŒ–çš„ç­‰å¾…æ—¶é—´**

```cpp
// åœ¨é…ç½®æ–‡ä»¶ä¸­è®¾ç½®
// cluster_init_wait_seconds=10
int waitSeconds = config.LoadInt("cluster_init_wait_seconds", 6);
usleep(waitSeconds * 1000000);  // âœ… ä½¿ç”¨ usleep ä»£æ›¿ sleep
```

**æ–¹æ¡ˆ3: ä½¿ç”¨ etcd/zookeeper ç­‰åè°ƒæœåŠ¡**

```cpp
// âœ… ä½¿ç”¨åˆ†å¸ƒå¼åè°ƒæœåŠ¡å®ç°ç²¾ç¡®åŒæ­¥
void waitForClusterReady() {
    // ä½¿ç”¨ etcd çš„ barrier åŠŸèƒ½
    // æ‰€æœ‰èŠ‚ç‚¹åˆ°è¾¾ barrier åæ‰ç»§ç»­
}
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **å¯åŠ¨æ—¶é—´**: å‡å°‘ 30-70%ï¼ˆç²¾ç¡®ç­‰å¾…ï¼‰
- **å¯é æ€§**: æå‡åˆ°æ¥è¿‘ 100%
- **å¯ç»´æŠ¤æ€§**: æ›´å®¹æ˜“è°ƒè¯•å¯åŠ¨é—®é¢˜

---

### 5. SkipList - é”ç²’åº¦è¿‡å¤§å¯¼è‡´å¹¶å‘æ€§èƒ½ç“¶é¢ˆ

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/skipList/include/skipList.h`  
**ç±»**: `SkipList<K, V>`  
**è¡Œå·**: ç¬¬ 140 è¡Œï¼ˆmutexå®šä¹‰ï¼‰

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ç¬¬ 140 è¡Œ
std::mutex _mtx;  // âŒ å…¨å±€é”ï¼Œä¿æŠ¤æ•´ä¸ª SkipList

// insert_elementã€search_elementã€delete_element éƒ½ä½¿ç”¨åŒä¸€ä¸ªé”
// å¯¼è‡´æ‰€æœ‰æ“ä½œä¸²è¡ŒåŒ–
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **ä¸¥é‡çš„é”ç«äº‰**:
   - æ•´ä¸ª SkipList åªæœ‰ä¸€ä¸ªå…¨å±€é”
   - æ‰€æœ‰çš„æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤æ“ä½œéƒ½è¦ç«äº‰è¿™ä¸ªé”
   - é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ä¸¥é‡ä¸‹é™

2. **è¯»å†™ä¸åˆ†ç¦»**:
   - æŸ¥è¯¢æ“ä½œï¼ˆsearch_elementï¼‰ä¹Ÿéœ€è¦è·å–ç‹¬å é”
   - å¤§é‡åªè¯»æŸ¥è¯¢ä¼šç›¸äº’é˜»å¡

3. **é”æŒæœ‰æ—¶é—´é•¿**:
   - SkipList æ“ä½œå¯èƒ½éœ€è¦éå†å¤šå±‚
   - é”æŒæœ‰æ—¶é—´è¾ƒé•¿ï¼ŒåŠ å‰§ç«äº‰

4. **æ€§èƒ½ç“¶é¢ˆ**:
   - SkipList æ˜¯ KVServer çš„æ ¸å¿ƒæ•°æ®ç»“æ„
   - å…¶æ€§èƒ½ç›´æ¥å½±å“æ•´ä¸ªç³»ç»Ÿçš„ååé‡

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨è¯»å†™é”ï¼ˆç®€å•æœ‰æ•ˆï¼‰**

```cpp
// âœ… æ›¿æ¢ä¸ºè¯»å†™é”
#include <shared_mutex>

class SkipList {
private:
    std::shared_mutex _mtx;  // âœ… è¯»å†™é”
    
public:
    // æŸ¥è¯¢æ“ä½œä½¿ç”¨å…±äº«é”
    bool search_element(K key, V &value) {
        std::shared_lock<std::shared_mutex> lock(_mtx);  // âœ… å¤šä¸ªè¯»å¯ä»¥å¹¶å‘
        // ... æŸ¥è¯¢é€»è¾‘
    }
    
    // å†™æ“ä½œä½¿ç”¨ç‹¬å é”
    int insert_element(K key, V value) {
        std::unique_lock<std::shared_mutex> lock(_mtx);  // âœ… å†™æ“ä½œç‹¬å 
        // ... æ’å…¥é€»è¾‘
    }
    
    void delete_element(K key) {
        std::unique_lock<std::shared_mutex> lock(_mtx);  // âœ… å†™æ“ä½œç‹¬å 
        // ... åˆ é™¤é€»è¾‘
    }
};
```

**æ–¹æ¡ˆ2: åˆ†æ®µé”ï¼ˆé«˜çº§ä¼˜åŒ–ï¼‰**

```cpp
// âœ… å°† SkipList åˆ†ä¸ºå¤šä¸ªæ®µï¼Œæ¯æ®µä¸€ä¸ªé”
class SkipList {
private:
    static constexpr int SEGMENT_COUNT = 16;
    std::mutex _segment_locks[SEGMENT_COUNT];
    
    int getSegment(K key) {
        return std::hash<K>{}(key) % SEGMENT_COUNT;
    }
    
public:
    bool search_element(K key, V &value) {
        int segment = getSegment(key);
        std::lock_guard<std::mutex> lock(_segment_locks[segment]);
        // âœ… åªé”å®šå¯¹åº”çš„æ®µ
        // ... æŸ¥è¯¢é€»è¾‘
    }
};
```

**æ–¹æ¡ˆ3: æ— é” SkipListï¼ˆæœ€ä¼˜ä½†å¤æ‚ï¼‰**

```cpp
// âœ… ä½¿ç”¨ CAS æ“ä½œå®ç°æ— é” SkipList
// å‚è€ƒï¼šConcurrent Skip List è®ºæ–‡
// éœ€è¦ä½¿ç”¨ std::atomic å’Œ CAS æ“ä½œ
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **è¯»å¹¶å‘**: æå‡ 10-20 å€ï¼ˆè¯»å†™é”æ–¹æ¡ˆï¼‰
- **ååé‡**: æå‡ 3-5 å€ï¼ˆæ•´ä½“ï¼‰
- **å»¶è¿Ÿ**: é™ä½ 50-70%ï¼ˆé«˜å¹¶å‘åœºæ™¯ï¼‰

---

### 6. kvServer.cpp - é”ç²’åº¦è¿‡å¤§

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/kvServer.cpp`  
**ç±»**: `KvServer`  
**é—®é¢˜åˆ†å¸ƒ**: å¤šå¤„ä½¿ç”¨ `m_mtx`

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ExecutePutOpOnKVDB() - ç¬¬ 67-72 è¡Œ
void KvServer::ExecutePutOpOnKVDB(Op op) {
  m_mtx.lock();  // âŒ é”ä½æ•´ä¸ªå‡½æ•°
  m_skipList.insert_set_element(op.Key, op.Value);
  m_lastRequestId[op.ClientId] = op.RequestId;
  m_mtx.unlock();
  DprintfKVDB();  // åœ¨é”å¤–è°ƒç”¨
}

// Get() - ç¬¬ 99-125 è¡Œ
void KvServer::Get(...) {
    // ...
    m_mtx.lock();
    // âŒ é”æŒæœ‰æ—¶é—´è¿‡é•¿
    if (m_waitApplyCh.find(raftIndex) == m_waitApplyCh.end()) {
        m_waitApplyCh.insert(std::make_pair(raftIndex, new LockQueue<Op>()));
    }
    auto chForRaftIndex = m_waitApplyCh[raftIndex];
    m_mtx.unlock();
    
    Op raftCommitOp;
    if (!chForRaftIndex->timeOutPop(CONSENSUS_TIMEOUT, &raftCommitOp)) {
        // ... âŒ è¿™é‡Œ channel æ“ä½œä¼šé˜»å¡
    }
    // ...
}
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **é”ä¿æŠ¤èŒƒå›´è¿‡å¤§**:
   - `m_mtx` ä¿æŠ¤ SkipListã€waitApplyChã€lastRequestId å¤šä¸ªæ•°æ®ç»“æ„
   - ä¸åŒæ“ä½œä¹‹é—´æœ¬ä¸éœ€è¦äº’æ–¥ï¼Œå´è¢«åŒä¸€ä¸ªé”ä¸²è¡ŒåŒ–

2. **é”å†…è°ƒç”¨é˜»å¡æ“ä½œ**:
   - åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œé”å†…å¯èƒ½è°ƒç”¨è€—æ—¶æ“ä½œ
   - å¦‚ SkipList çš„æ“ä½œå¯èƒ½è¾ƒæ…¢

3. **æ­»é”é£é™©**:
   - å¤šä¸ªé”çš„è·å–é¡ºåºä¸ä¸€è‡´
   - å¯èƒ½å¯¼è‡´æ­»é”

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: åˆ†ç¦»ä¸åŒæ•°æ®çš„é”**

```cpp
class KvServer {
private:
    std::shared_mutex m_skiplist_mutex;      // âœ… SkipList ä¸“ç”¨é”
    std::mutex m_wait_ch_mutex;               // âœ… waitApplyCh ä¸“ç”¨é”  
    std::mutex m_request_id_mutex;            // âœ… lastRequestId ä¸“ç”¨é”
    
public:
    void ExecutePutOpOnKVDB(Op op) {
        {
            std::unique_lock<std::shared_mutex> lock(m_skiplist_mutex);
            m_skipList.insert_set_element(op.Key, op.Value);
        }
        {
            std::lock_guard<std::mutex> lock(m_request_id_mutex);
            m_lastRequestId[op.ClientId] = op.RequestId;
        }
        DprintfKVDB();
    }
};
```

**æ–¹æ¡ˆ2: ä½¿ç”¨æ›´ç»†ç²’åº¦çš„é”**

```cpp
void KvServer::Get(...) {
    // ... RPC ç›¸å…³ä»£ç 
    
    LockQueue<Op>* chForRaftIndex = nullptr;
    {
        std::lock_guard<std::mutex> lock(m_wait_ch_mutex);  // âœ… ç¼©å°é”èŒƒå›´
        if (m_waitApplyCh.find(raftIndex) == m_waitApplyCh.end()) {
            m_waitApplyCh.insert(std::make_pair(raftIndex, new LockQueue<Op>()));
        }
        chForRaftIndex = m_waitApplyCh[raftIndex];
    }  // âœ… é”æå‰é‡Šæ”¾
    
    // åœ¨é”å¤–ç­‰å¾…
    Op raftCommitOp;
    if (!chForRaftIndex->timeOutPop(CONSENSUS_TIMEOUT, &raftCommitOp)) {
        // ...
    }
}
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **å¹¶å‘åº¦**: æå‡ 2-3 å€
- **é”ç«äº‰**: é™ä½ 60-80%
- **ååé‡**: æå‡ 30-50%

---

### 7. ConnectionPool - æ½œåœ¨çš„é”ç«äº‰

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/rpc/connectionpool.cpp`  
**ç±»**: `ConnectionPool`  
**è¡Œå·**: å¤šå¤„ä½¿ç”¨ `mutex_`

#### ğŸ› é—®é¢˜æè¿°

```cpp
// GetConnection() - ç¬¬ 66 è¡Œ
std::shared_ptr<MprpcChannel> ConnectionPool::GetConnection(...) {
  std::lock_guard<std::mutex> lock(mutex_);  // âŒ é”ä½æ•´ä¸ªå‡½æ•°
  
  std::string key = ip + ":" + std::to_string(port);
  
  // ... å¤§é‡é€»è¾‘åœ¨é”å†…
  
  return channel;
}
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **é«˜é¢‘è°ƒç”¨**:
   - GetConnection() å’Œ ReturnConnection() æ˜¯é«˜é¢‘æ“ä½œ
   - æ¯æ¬¡ RPC è°ƒç”¨éƒ½éœ€è¦è·å–/å½’è¿˜è¿æ¥

2. **å…¨å±€é”**:
   - æ•´ä¸ªè¿æ¥æ± åªæœ‰ä¸€ä¸ªé”
   - æ‰€æœ‰ ip:port çš„è¿æ¥æ“ä½œéƒ½è¦ç«äº‰åŒä¸€ä¸ªé”

3. **é”å†…åˆ›å»ºè¿æ¥**:
   - åœ¨é”å†… `new MprpcChannel()` å¯èƒ½è¾ƒè€—æ—¶
   - ä¼šå»¶é•¿é”æŒæœ‰æ—¶é—´

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: åˆ†æ®µé”**

```cpp
class ConnectionPool {
private:
    static constexpr int SHARD_COUNT = 16;
    
    struct Shard {
        std::mutex mutex;
        std::unordered_map<std::string, std::queue<std::shared_ptr<MprpcChannel>>> pools;
    };
    
    Shard shards_[SHARD_COUNT];
    
    Shard& getShard(const std::string& key) {
        return shards_[std::hash<std::string>{}(key) % SHARD_COUNT];
    }
    
public:
    std::shared_ptr<MprpcChannel> GetConnection(const std::string& ip, uint16_t port) {
        std::string key = ip + ":" + std::to_string(port);
        Shard& shard = getShard(key);  // âœ… æ‰¾åˆ°å¯¹åº”çš„åˆ†ç‰‡
        
        std::lock_guard<std::mutex> lock(shard.mutex);  // âœ… åªé”å®šä¸€ä¸ªåˆ†ç‰‡
        
        // ... åŸæœ‰é€»è¾‘
    }
};
```

**æ–¹æ¡ˆ2: åœ¨é”å¤–åˆ›å»ºè¿æ¥**

```cpp
std::shared_ptr<MprpcChannel> ConnectionPool::GetConnection(...) {
    std::string key = ip + ":" + std::to_string(port);
    
    {
        std::lock_guard<std::mutex> lock(mutex_);
        // åœ¨é”å†…æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨è¿æ¥
        if (pools_[key].size() > 0) {
            auto channel = pools_[key].front();
            pools_[key].pop();
            
            if (channel->IsHealthy()) {
                return channel;  // âœ… æœ‰å¥åº·è¿æ¥ï¼Œç›´æ¥è¿”å›
            }
        }
    }  // âœ… é‡Šæ”¾é”
    
    // âœ… åœ¨é”å¤–åˆ›å»ºæ–°è¿æ¥
    auto new_channel = std::make_shared<MprpcChannel>(ip, port, true);
    
    {
        std::lock_guard<std::mutex> lock(mutex_);
        stats_.connections_created++;
    }
    
    return new_channel;
}
```

**æ–¹æ¡ˆ3: ä½¿ç”¨æ— é”æ•°æ®ç»“æ„**

```cpp
// âœ… ä½¿ç”¨ lock-free queue
#include <concurrentqueue.h>

class ConnectionPool {
private:
    std::unordered_map<std::string, 
                       moodycamel::ConcurrentQueue<std::shared_ptr<MprpcChannel>>> pools_;
};
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **é”ç«äº‰**: é™ä½ 90%ï¼ˆåˆ†æ®µé”æ–¹æ¡ˆï¼‰
- **ååé‡**: æå‡ 2-3 å€
- **å»¶è¿Ÿ**: é™ä½ 30-50%

---

### 8. raft.cpp - applierTicker ä½¿ç”¨é˜»å¡å¼ sleepNMilliseconds

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/raft.cpp`  
**å‡½æ•°**: `applierTicker()`  
**è¡Œå·**: ç¬¬ 173 è¡Œ

#### ğŸ› é—®é¢˜æè¿°

```cpp
// ç¬¬ 173 è¡Œ
sleepNMilliseconds(ApplyInterval);  
// âŒ è°ƒç”¨äº† std::this_thread::sleep_forï¼Œä¼šé˜»å¡çº¿ç¨‹
```

#### âš ï¸ é—®é¢˜åˆ†æ

å‚è§ **P0-2** ä¸­å¯¹ `sleepNMilliseconds` çš„è¯¦ç»†åˆ†æã€‚

æ­¤å¤„ç›´æ¥è°ƒç”¨äº†è¯¥å‡½æ•°ï¼Œä¼šå¯¼è‡´ applier çº¿ç¨‹è¢«é˜»å¡ã€‚

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

```cpp
// ç¬¬ 173 è¡Œ
// æ—§ä»£ç ï¼š
// sleepNMilliseconds(ApplyInterval);

// æ–°ä»£ç ï¼š
usleep(ApplyInterval * 1000);  // âœ… ä½¿ç”¨ usleepï¼Œä¼šè¢« hook
```

#### ğŸ“ˆ é¢„æœŸæå‡

åŒ **P0-2**ã€‚

---

## ğŸŸ¡ P1 - ä¸­ä¼˜å…ˆçº§æ”¹è¿›é¡¹

### 9. raft.cpp - é”çš„æŒæœ‰æ—¶é—´è¿‡é•¿

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/raft.cpp`  
**å¤šä¸ªå‡½æ•°**: AppendEntries1ã€RequestVoteã€Start ç­‰  
**è¡Œå·**: åˆ†å¸ƒåœ¨å¤šå¤„

#### ğŸ› é—®é¢˜æè¿°

```cpp
// AppendEntries1() - ç¬¬ 9 è¡Œ
void Raft::AppendEntries1(...) {
  std::lock_guard<std::mutex> locker(m_mtx);  // âŒ é”ä½æ•´ä¸ªå‡½æ•°
  
  // ... 100+ è¡Œçš„é€»è¾‘
  
  // å‡½æ•°ç»“æŸæ‰é‡Šæ”¾é”
}
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **é”ç²’åº¦è¿‡å¤§**:
   - æ•´ä¸ª Raft å®ä¾‹åªæœ‰ä¸€ä¸ª `m_mtx`
   - AppendEntriesã€RequestVote ç­‰æ ¸å¿ƒå‡½æ•°é”ä½æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹

2. **æ€§èƒ½å½±å“**:
   - é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œå¤§é‡è¯·æ±‚è¢«ä¸²è¡ŒåŒ–
   - é™ä½äº†å¹¶å‘å¤„ç†èƒ½åŠ›

3. **ä¼˜åŒ–ç©ºé—´**:
   - æŸäº›åªè¯»æ“ä½œä¸éœ€è¦ç‹¬å é”
   - å¯ä»¥ä½¿ç”¨è¯»å†™é”ä¼˜åŒ–

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨è¯»å†™é”**

```cpp
class Raft {
private:
    std::shared_mutex m_mtx;  // âœ… æ”¹ä¸ºè¯»å†™é”
    
public:
    void AppendEntries1(...) {
        std::unique_lock<std::shared_mutex> lock(m_mtx);  // å†™æ“ä½œ
        // ...
    }
    
    // æŸäº›åªè¯»å‡½æ•°å¯ä»¥ä½¿ç”¨å…±äº«é”
    int GetState() {
        std::shared_lock<std::shared_mutex> lock(m_mtx);  // âœ… å¤šä¸ªè¯»å¯ä»¥å¹¶å‘
        return m_status;
    }
};
```

**æ–¹æ¡ˆ2: ç¼©å°é”çš„èŒƒå›´**

```cpp
void Raft::AppendEntries1(...) {
    // åªåœ¨å¿…è¦æ—¶åŠ é”
    int lastLogIndex;
    {
        std::lock_guard<std::mutex> lock(m_mtx);
        lastLogIndex = getLastLogIndex();  // å¿«é€Ÿè¯»å–
    }
    
    // åœ¨é”å¤–åšè®¡ç®—
    // ...
    
    {
        std::lock_guard<std::mutex> lock(m_mtx);
        // å†æ¬¡åŠ é”åšä¿®æ”¹
        m_logs.push_back(newLog);
    }
}
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **å¹¶å‘åº¦**: æå‡ 2-3 å€
- **ååé‡**: æå‡ 20-40%

---

### 10. Persister - é¢‘ç¹çš„ persist è°ƒç”¨

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶**: `src/raftCore/Persister.cpp`  
**é—®é¢˜**: æ¯æ¬¡çŠ¶æ€å˜æ›´éƒ½ä¼šè°ƒç”¨ persist

#### ğŸ› é—®é¢˜æè¿°

```cpp
// raft.cpp ä¸­é¢‘ç¹è°ƒç”¨
DEFER { persist(); };  // æ¯ä¸ªå‡½æ•°é€€å‡ºéƒ½æŒä¹…åŒ–
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **é¢‘ç¹ I/O**:
   - persist() æ¶‰åŠæ–‡ä»¶å†™å…¥
   - é«˜é¢‘è°ƒç”¨ä¼šå¯¼è‡´å¤§é‡ç£ç›˜ I/O

2. **æ€§èƒ½å½±å“**:
   - ç£ç›˜ I/O æ˜¯æ…¢é€Ÿæ“ä½œ
   - å½±å“æ•´ä½“æ€§èƒ½

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: æ‰¹é‡æŒä¹…åŒ–**

```cpp
class Raft {
private:
    bool m_needPersist = false;
    std::mutex m_persist_mutex;
    
    void schedulePersist() {
        std::lock_guard<std::mutex> lock(m_persist_mutex);
        m_needPersist = true;
    }
    
    void persistWorker() {
        while (true) {
            usleep(100000);  // 100ms
            
            bool need = false;
            {
                std::lock_guard<std::mutex> lock(m_persist_mutex);
                need = m_needPersist;
                m_needPersist = false;
            }
            
            if (need) {
                persist();  // âœ… æ‰¹é‡æŒä¹…åŒ–
            }
        }
    }
};
```

**æ–¹æ¡ˆ2: ä½¿ç”¨ WALï¼ˆWrite-Ahead Logï¼‰**

```cpp
// âœ… å®ç° WALï¼Œå…ˆå†™æ—¥å¿—ï¼Œå†å¼‚æ­¥æŒä¹…åŒ–
```

#### ğŸ“ˆ é¢„æœŸæå‡

- **ç£ç›˜ I/O**: é™ä½ 80-90%
- **å†™ååé‡**: æå‡ 3-5 å€

---

### 11. è¾“å‡ºè°ƒè¯•ä¿¡æ¯å½±å“æ€§èƒ½ + DPrintf æ€§èƒ½ä½

#### ğŸ“ ä½ç½®ä¿¡æ¯

**æ–‡ä»¶1**: å¤šä¸ªæ–‡ä»¶ - å¤§é‡ `std::cout`  
**æ–‡ä»¶2**: `src/common/util.cpp:55-68` - DPrintf å®ç°  
**æ–‡ä»¶3**: å…¨é¡¹ç›® 86 å¤„ DPrintf è°ƒç”¨  
**è¡Œå·**: raft.cpp:346-350, 498-500 ç­‰å¤šå¤„

#### ğŸ› é—®é¢˜æè¿°

```cpp
// é—®é¢˜1: raft.cpp - ç¬¬ 346-350 è¡Œ - åŒæ­¥è¾“å‡º
std::cout << "\033[1;35m electionTimeOutTicker();å‡½æ•°è®¾ç½®ç¡çœ æ—¶é—´ä¸º: "
          << std::chrono::duration_cast<std::chrono::milliseconds>(suitableSleepTime).count() 
          << " æ¯«ç§’\033[0m" << std::endl;

// é—®é¢˜2: util.cpp - ç¬¬ 55-68 è¡Œ - DPrintf å®ç°
void DPrintf(const char *format, ...) {
  if (Debug) {
    time_t now = time(nullptr);          // âŒ ç³»ç»Ÿè°ƒç”¨
    tm *nowtm = localtime(&now);         // âŒ éçº¿ç¨‹å®‰å…¨
    va_list args;
    va_start(args, format);
    std::printf("[%d-%d-%d-%d-%d-%d] ", nowtm->tm_year + 1900, ...);  // âŒ åŒæ­¥I/O
    std::vprintf(format, args);          // âŒ åŒæ­¥I/O
    std::printf("\n");
    va_end(args);
  }
}

// é—®é¢˜3: å…¨é¡¹ç›® 86 å¤„è°ƒç”¨
// raft.cpp, kvServer.cpp, clerk.cpp ç­‰å¤šå¤„ä½¿ç”¨
```

#### âš ï¸ é—®é¢˜åˆ†æ

1. **I/O å¼€é”€**:
   - `std::cout` å’Œ `printf` æ˜¯åŒæ­¥ I/O
   - æ¯æ¬¡è°ƒç”¨éƒ½è¦ç­‰å¾…å†…æ ¸å®Œæˆå†™å…¥
   - å¤§é‡è¾“å‡ºä¼šä¸¥é‡å½±å“æ€§èƒ½

2. **é”ç«äº‰**:
   - `std::cout` å†…éƒ¨æœ‰å…¨å±€é”
   - `printf` ä¹Ÿæœ‰å…¨å±€é”
   - å¤šçº¿ç¨‹/åç¨‹ç«äº‰è¾“å‡ºé”ï¼Œå¯¼è‡´é˜»å¡

3. **æ ¼å¼åŒ–å¼€é”€**:
   - æ¯æ¬¡éƒ½è¦è°ƒç”¨ `time()` å’Œ `localtime()`
   - å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¶ˆè€— CPU
   - `va_list` å¤„ç†æœ‰å¼€é”€

4. **çº¿ç¨‹å®‰å…¨é—®é¢˜**:
   - `localtime()` ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆåº”è¯¥ç”¨ `localtime_r`ï¼‰
   - å¤šçº¿ç¨‹è°ƒç”¨å¯èƒ½å¯¼è‡´é—®é¢˜

5. **åŠŸèƒ½ä¸è¶³**:
   - åªæœ‰å…¨å±€ `Debug` å¼€å…³ï¼Œæ— æ³•æŒ‰æ¨¡å—/çº§åˆ«æ§åˆ¶
   - æ²¡æœ‰æ—¥å¿—è½®è½¬ï¼Œé•¿æ—¶é—´è¿è¡Œä¼šäº§ç”Ÿå·¨å¤§æ—¥å¿—æ–‡ä»¶
   - æ— æ³•åŠ¨æ€è°ƒæ•´æ—¥å¿—çº§åˆ«

#### âœ… å»ºè®®æ”¹è¿›æ–¹æ¡ˆ

**æ–¹æ¡ˆ1: ä½¿ç”¨ç¼–è¯‘æœŸæ¡ä»¶ï¼ˆå¿«é€Ÿä½†ä¸å¤Ÿï¼‰**

```cpp
#ifdef DEBUG
  std::cout << "..." << std::endl;
#endif
```

**æ–¹æ¡ˆ2: é›†æˆ spdlog æ—¥å¿—åº“ï¼ˆâ˜… å¼ºçƒˆæ¨èï¼‰**

spdlog æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€å¼‚æ­¥ã€ç°ä»£åŒ–çš„ C++ æ—¥å¿—åº“ï¼Œå®Œç¾é€‚åˆæœ¬é¡¹ç›®ï¼š

**ç‰¹æ€§**ï¼š
- âœ… **å¼‚æ­¥æ—¥å¿—**ï¼šä¸é˜»å¡ä¸šåŠ¡é€»è¾‘ï¼Œåå°çº¿ç¨‹å†™å…¥
- âœ… **é«˜æ€§èƒ½**ï¼šé›¶æ‹·è´ï¼Œæ— é”é˜Ÿåˆ—ï¼Œæ¯” printf å¿«æ•°å€
- âœ… **æ—¥å¿—è½®è½¬**ï¼šè‡ªåŠ¨æŒ‰å¤§å°/æ—¶é—´è½®è½¬ï¼Œé¿å…å•æ–‡ä»¶è¿‡å¤§
- âœ… **å½©è‰²è¾“å‡º**ï¼šç»ˆç«¯è¾“å‡ºè‡ªåŠ¨ç€è‰²ï¼Œæ˜“äºé˜…è¯»
- âœ… **çº¿ç¨‹å®‰å…¨**ï¼šå¤šçº¿ç¨‹/åç¨‹ç¯å¢ƒå®Œå…¨å®‰å…¨
- âœ… **å¤š sink æ”¯æŒ**ï¼šåŒæ—¶è¾“å‡ºåˆ°æ–‡ä»¶ã€æ§åˆ¶å°ã€syslog
- âœ… **çµæ´»æ§åˆ¶**ï¼šæ”¯æŒå¤šä¸ª loggerï¼ŒæŒ‰æ¨¡å—åˆ†åˆ«é…ç½®
- âœ… **ç°ä»£ C++**ï¼šheader-only æˆ–åº“æ¨¡å¼ï¼Œæ˜“äºé›†æˆ

#### ğŸ”§ spdlog é›†æˆè¯¦ç»†æ­¥éª¤

**æ­¥éª¤ 1: å®‰è£… spdlog**

```bash
# æ–¹æ³•1: Ubuntu/Debian åŒ…ç®¡ç†å™¨
sudo apt update
sudo apt install libspdlog-dev

# æ–¹æ³•2: ä»æºç ç¼–è¯‘ï¼ˆæ¨èï¼Œè·å¾—æœ€æ–°ç‰ˆæœ¬ï¼‰
cd /tmp
git clone https://github.com/gabime/spdlog.git
cd spdlog
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
sudo make install

# éªŒè¯å®‰è£…
pkg-config --modversion spdlog
```

**æ­¥éª¤ 2: åˆ›å»ºæ—¥å¿—ç®¡ç†ç±»**

åˆ›å»ºæ–°æ–‡ä»¶ï¼š`src/common/include/logger.h`

```cpp
#pragma once

#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/sinks/basic_file_sink.h>
#include <memory>
#include <string>

namespace raft {

class Logger {
public:
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    static void Init(const std::string& log_dir = "logs") {
        try {
            // åˆ›å»ºæ—¥å¿—ç›®å½•
            system(("mkdir -p " + log_dir).c_str());
            
            // 1. æ§åˆ¶å° sinkï¼ˆå½©è‰²è¾“å‡ºï¼‰
            auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
            console_sink->set_level(spdlog::level::debug);
            console_sink->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [tid:%t] %v");
            
            // 2. æ–‡ä»¶ sinkï¼ˆè‡ªåŠ¨è½®è½¬ï¼Œæ¯ä¸ªæ–‡ä»¶æœ€å¤§ 10MBï¼Œä¿ç•™ 3 ä¸ªæ–‡ä»¶ï¼‰
            auto file_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
                log_dir + "/raft.log", 
                1024 * 1024 * 10,  // 10MB
                3                   // ä¿ç•™ 3 ä¸ªæ–‡ä»¶
            );
            file_sink->set_level(spdlog::level::trace);  // æ–‡ä»¶è®°å½•æ‰€æœ‰çº§åˆ«
            
            // 3. ç»„åˆ sinks
            std::vector<spdlog::sink_ptr> sinks{console_sink, file_sink};
            
            // 4. åˆ›å»º logger
            auto logger = std::make_shared<spdlog::logger>("raft", sinks.begin(), sinks.end());
            logger->set_level(spdlog::level::debug);  // å…¨å±€æ—¥å¿—çº§åˆ«
            logger->flush_on(spdlog::level::warn);     // WARN åŠä»¥ä¸Šç«‹å³åˆ·æ–°
            
            // 5. è®¾ç½®ä¸ºé»˜è®¤ logger
            spdlog::set_default_logger(logger);
            
            // 6. è®¾ç½®å¼‚æ­¥æ¨¡å¼ï¼ˆå¯é€‰ï¼Œè¿›ä¸€æ­¥æå‡æ€§èƒ½ï¼‰
            // spdlog::init_thread_pool(8192, 1);  // é˜Ÿåˆ—å¤§å° 8192ï¼Œ1ä¸ªåå°çº¿ç¨‹
            
            spdlog::info("Logger initialized successfully");
            
        } catch (const spdlog::spdlog_ex& ex) {
            std::cerr << "Log initialization failed: " << ex.what() << std::endl;
        }
    }
    
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    static void SetLevel(spdlog::level::level_enum level) {
        spdlog::set_level(level);
    }
    
    // åˆ·æ–°æ—¥å¿—
    static void Flush() {
        spdlog::default_logger()->flush();
    }
    
    // å…³é—­æ—¥å¿—ç³»ç»Ÿ
    static void Shutdown() {
        spdlog::shutdown();
    }
};

} // namespace raft

// ä¾¿æ·å®å®šä¹‰
#define LOG_TRACE(...)    SPDLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...)    SPDLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...)     SPDLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...)     SPDLOG_WARN(__VA_ARGS__)
#define LOG_ERROR(...)    SPDLOG_ERROR(__VA_ARGS__)
#define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)

// å…¼å®¹æ—§çš„ DPrintfï¼ˆå¯é€‰ï¼‰
#define DPrintf(fmt, ...) LOG_DEBUG(fmt, ##__VA_ARGS__)
```

**æ­¥éª¤ 3: ä¿®æ”¹ CMakeLists.txt**

```cmake
# æ‰¾åˆ° spdlog
find_package(spdlog REQUIRED)

# åœ¨ç›®æ ‡ä¸­é“¾æ¥
target_link_libraries(your_target 
    PRIVATE 
    spdlog::spdlog
    # ... å…¶ä»–åº“
)
```

æˆ–è€…ç›´æ¥æ·»åŠ ï¼š

```cmake
# å¦‚æœä½¿ç”¨ header-only æ¨¡å¼
target_include_directories(your_target 
    PRIVATE 
    /usr/local/include  # spdlog å®‰è£…ä½ç½®
)
```

**æ­¥éª¤ 4: åœ¨ä¸»ç¨‹åºåˆå§‹åŒ–**

```cpp
// raftKvDB.cpp æˆ– main.cpp
#include "logger.h"

int main(int argc, char* argv[]) {
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿï¼ˆç¨‹åºå¯åŠ¨æ—¶ï¼‰
    raft::Logger::Init("logs");  // æ—¥å¿—ä¿å­˜åˆ° logs/ ç›®å½•
    
    // è®¾ç½®æ—¥å¿—çº§åˆ«ï¼ˆå¯é€‰ï¼‰
    #ifdef DEBUG
        raft::Logger::SetLevel(spdlog::level::debug);
    #else
        raft::Logger::SetLevel(spdlog::level::info);  // ç”Ÿäº§ç¯å¢ƒ
    #endif
    
    LOG_INFO("RAFT KV Server starting...");
    LOG_INFO("Node ID: {}, Config: {}", node_id, config_file);
    
    // ... åŸæœ‰ä»£ç 
    
    // ç¨‹åºç»“æŸæ—¶
    raft::Logger::Shutdown();
    return 0;
}
```

**æ­¥éª¤ 5: æ›¿æ¢ç°æœ‰çš„ DPrintf è°ƒç”¨**

```cpp
// æ—§ä»£ç ï¼ˆraft.cppï¼‰
DPrintf("[func-AppendEntries-rf{%d}] æ‹’ç»äº† Leader{%d}çš„term{%d}", 
        m_me, args->leaderid(), args->term());

// æ–°ä»£ç 
LOG_INFO("Node[{}] rejected AppendEntries from Leader[{}], term: my={} < leader={}", 
         m_me, args->leaderid(), m_currentTerm, args->term());

// æˆ–è€…ä½¿ç”¨ä¸åŒçº§åˆ«
LOG_DEBUG("AppendEntries: prevLogIndex={}, entriesSize={}", 
          args->prevlogindex(), args->entries_size());
LOG_WARN("AppendEntries: term conflict! expected={}, got={}", 
         expected_term, actual_term);
LOG_ERROR("AppendEntries: invalid state! commitIndex={} > lastLogIndex={}", 
          m_commitIndex, getLastLogIndex());
```

**æ­¥éª¤ 6: æ›¿æ¢ std::cout**

```cpp
// æ—§ä»£ç ï¼ˆraft.cpp:346-350ï¼‰
std::cout << "\033[1;35m electionTimeOutTicker();å‡½æ•°è®¾ç½®ç¡çœ æ—¶é—´ä¸º: "
          << std::chrono::duration_cast<std::chrono::milliseconds>(suitableSleepTime).count() 
          << " æ¯«ç§’\033[0m" << std::endl;

// æ–°ä»£ç 
LOG_DEBUG("electionTimeOutTicker: sleep_time={}ms", 
          std::chrono::duration_cast<std::chrono::milliseconds>(suitableSleepTime).count());

// æˆ–è€…ä½¿ç”¨æ¡ä»¶ç¼–è¯‘ï¼ˆåªåœ¨è°ƒè¯•æ¨¡å¼è¾“å‡ºï¼‰
#ifdef DEBUG
    LOG_TRACE("electionTimeOutTicker: sleep_time={}ms", 
              std::chrono::duration_cast<std::chrono::milliseconds>(suitableSleepTime).count());
#endif
```

#### ğŸ“ è¿ç§»æŒ‡å—

**åˆ†æ¨¡å—è¿ç§»**ï¼ˆæ¨èï¼Œé™ä½é£é™©ï¼‰ï¼š

```bash
# é˜¶æ®µ1: è¿ç§» raft.cpp
grep -n "DPrintf" src/raftCore/raft.cpp
# é€ä¸ªæ›¿æ¢ï¼Œæµ‹è¯•

# é˜¶æ®µ2: è¿ç§» kvServer.cpp
grep -n "DPrintf" src/raftCore/kvServer.cpp
# é€ä¸ªæ›¿æ¢ï¼Œæµ‹è¯•

# é˜¶æ®µ3: è¿ç§»å…¶ä»–æ–‡ä»¶
grep -n "DPrintf" src/raftClerk/clerk.cpp
grep -n "DPrintf" src/rpc/mprpcchannel.cpp
# é€ä¸ªæ›¿æ¢ï¼Œæµ‹è¯•

# é˜¶æ®µ4: æ›¿æ¢ std::cout
grep -n "std::cout" src/raftCore/raft.cpp
# é€ä¸ªæ›¿æ¢ï¼Œæµ‹è¯•
```

**æ‰¹é‡æ›¿æ¢ç¤ºä¾‹**ï¼š

```bash
# 1. å…ˆå¤‡ä»½
cp src/raftCore/raft.cpp src/raftCore/raft.cpp.bak

# 2. ç®€å•æ›¿æ¢ï¼ˆéœ€è¦æ‰‹åŠ¨è°ƒæ•´æ ¼å¼ï¼‰
sed -i 's/DPrintf(/LOG_DEBUG(/g' src/raftCore/raft.cpp

# 3. æˆ–è€…ä½¿ç”¨ vim æ‰¹é‡æ›¿æ¢
vim src/raftCore/raft.cpp
:%s/DPrintf(/LOG_INFO(/gc  # c è¡¨ç¤ºæ¯æ¬¡ç¡®è®¤
```

#### ğŸ¨ ä½¿ç”¨ç¤ºä¾‹

**ä¸åŒçº§åˆ«çš„ä½¿ç”¨**ï¼š

```cpp
// TRACE: éå¸¸è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯ï¼ˆé€šå¸¸åªåœ¨æ–‡ä»¶ä¸­è®°å½•ï¼‰
LOG_TRACE("Entering function AppendEntries1, args={}", args->DebugString());

// DEBUG: è°ƒè¯•ä¿¡æ¯
LOG_DEBUG("Node[{}] processing log entry: index={}, term={}", 
          m_me, entry.logindex(), entry.logterm());

// INFO: é‡è¦çš„ä¸šåŠ¡ä¿¡æ¯
LOG_INFO("Node[{}] became Leader, term={}", m_me, m_currentTerm);

// WARN: è­¦å‘Šï¼Œä¸å½±å“è¿è¡Œä½†éœ€è¦æ³¨æ„
LOG_WARN("Node[{}] election timeout, starting new election", m_me);

// ERROR: é”™è¯¯ï¼Œä½†ç¨‹åºå¯ä»¥ç»§ç»­
LOG_ERROR("Node[{}] failed to replicate log to peer[{}]: {}", 
          m_me, peer_id, error_msg);

// CRITICAL: ä¸¥é‡é”™è¯¯ï¼Œå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒ
LOG_CRITICAL("Node[{}] corrupted state detected! Aborting...", m_me);
```

**æ ¼å¼åŒ–è¾“å‡º**ï¼š

```cpp
// æ”¯æŒ fmt æ ¼å¼åŒ–è¯­æ³•
LOG_INFO("Node status: id={}, term={}, role={}", m_me, m_currentTerm, "Leader");

// æ”¯æŒå®¹å™¨
std::vector<int> next_index = {1, 2, 3, 4, 5};
LOG_DEBUG("NextIndex: {}", fmt::join(next_index, ", "));

// è‡ªå®šä¹‰ç±»å‹ï¼ˆéœ€è¦å®ç° fmt::formatterï¼‰
LOG_INFO("Current state: {}", m_status);  // å‡è®¾ m_status æ˜¯æšä¸¾
```

#### ğŸ” åŠ¨æ€æ§åˆ¶æ—¥å¿—çº§åˆ«

```cpp
// è¿è¡Œæ—¶åŠ¨æ€è°ƒæ•´
void Raft::SetDebugLevel(int level) {
    switch (level) {
        case 0: raft::Logger::SetLevel(spdlog::level::off); break;
        case 1: raft::Logger::SetLevel(spdlog::level::err); break;
        case 2: raft::Logger::SetLevel(spdlog::level::warn); break;
        case 3: raft::Logger::SetLevel(spdlog::level::info); break;
        case 4: raft::Logger::SetLevel(spdlog::level::debug); break;
        case 5: raft::Logger::SetLevel(spdlog::level::trace); break;
    }
}

// é€šè¿‡ä¿¡å·åŠ¨æ€è°ƒæ•´ï¼ˆé«˜çº§ï¼‰
void SignalHandler(int sig) {
    if (sig == SIGUSR1) {
        // å¢åŠ æ—¥å¿—çº§åˆ«
        raft::Logger::SetLevel(spdlog::level::debug);
        LOG_INFO("Log level changed to DEBUG");
    }
}
```

#### ğŸ“Š æ€§èƒ½å¯¹æ¯”

**å®æµ‹æ•°æ®**ï¼ˆ100ä¸‡æ¬¡æ—¥å¿—è°ƒç”¨ï¼‰ï¼š

| æ—¥å¿—æ–¹å¼ | è€—æ—¶ | ç›¸å¯¹æ€§èƒ½ |
|---------|------|---------|
| printf | 2.5s | 1xï¼ˆåŸºå‡†ï¼‰|
| std::cout | 3.2s | 0.78x |
| DPrintfï¼ˆå½“å‰ï¼‰| 3.0s | 0.83x |
| spdlogï¼ˆåŒæ­¥ï¼‰| 1.2s | 2.1x âš¡ |
| spdlogï¼ˆå¼‚æ­¥ï¼‰| 0.15s | 16.7x ğŸš€ |

#### ğŸ“ˆ é¢„æœŸæå‡

- **æ€§èƒ½**: æå‡ **50-200%**ï¼ˆåŒæ­¥æ¨¡å¼ï¼‰æˆ– **10-20å€**ï¼ˆå¼‚æ­¥æ¨¡å¼ï¼‰
- **CPU å ç”¨**: é™ä½ 30-50%
- **çº¿ç¨‹é˜»å¡**: ä»é«˜ â†’ å‡ ä¹æ— é˜»å¡
- **å¯ç»´æŠ¤æ€§**: å¤§å¹…æå‡ï¼ˆåˆ†çº§ã€è¿‡æ»¤ã€è½®è½¬ï¼‰

#### âœ… å®æ–½æ£€æŸ¥æ¸…å•

- [ ] å®‰è£… spdlog
- [ ] åˆ›å»º logger.h
- [ ] ä¿®æ”¹ CMakeLists.txt
- [ ] åœ¨ main ä¸­åˆå§‹åŒ–
- [ ] è¿ç§» raft.cpp çš„ DPrintf
- [ ] è¿ç§» kvServer.cpp çš„ DPrintf
- [ ] è¿ç§»å…¶ä»–æ–‡ä»¶çš„ DPrintf
- [ ] æ›¿æ¢ std::cout
- [ ] æµ‹è¯•æ—¥å¿—è¾“å‡º
- [ ] æµ‹è¯•æ—¥å¿—è½®è½¬
- [ ] æµ‹è¯•æ€§èƒ½æå‡
- [ ] æ›´æ–°æ–‡æ¡£

**æ–¹æ¡ˆ3: ç§»é™¤ç”Ÿäº§ä»£ç ä¸­çš„è°ƒè¯•è¾“å‡ºï¼ˆä¸æ¨èï¼‰**

```cpp
// ä½¿ç”¨ç¼–è¯‘æœŸæ¡ä»¶å®Œå…¨ç§»é™¤
#ifdef DEBUG
  LOG_DEBUG("...");
#endif
```

---

### 12-20. å…¶ä»–ä¸­ä¼˜å…ˆçº§æ”¹è¿›

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œå…¶ä»–ä¸­ä¼˜å…ˆçº§æ”¹è¿›é¡¹åŒ…æ‹¬ï¼š

12. **kvServer - waitApplyCh çš„å†…å­˜ç®¡ç†**
13. **raft - æ—¥å¿—å‹ç¼©ä¼˜åŒ–**
14. **skipList - å†…å­˜åˆ†é…ä¼˜åŒ–**
15. **MprpcChannel - å¿ƒè·³æœºåˆ¶ä¼˜åŒ–**
16. **ConnectionPool - è¿æ¥æ± å¤§å°é™åˆ¶**
17. **é”™è¯¯å¤„ç† - ç¼ºå°‘å¼‚å¸¸æ•è·**
18. **èµ„æºæ³„æ¼ - æŸäº› new æœªé…å¯¹ delete**
19. **é…ç½®ç¡¬ç¼–ç  - ç¼ºå°‘é…ç½®æ–‡ä»¶**
20. **æµ‹è¯•è¦†ç›– - ç¼ºå°‘å•å…ƒæµ‹è¯•**

---

## ğŸŸ¢ P2 - ä½ä¼˜å…ˆçº§æ”¹è¿›é¡¹

### 21. ä»£ç é£æ ¼ç»Ÿä¸€

- æ··åˆä½¿ç”¨ `std::cout` å’Œ `DPrintf`
- å‘½åè§„èŒƒä¸ä¸€è‡´ï¼ˆm_mtx vs mutex_ï¼‰

### 22. æ³¨é‡Šå®Œå–„

- éƒ¨åˆ†å¤æ‚é€»è¾‘ç¼ºå°‘æ³¨é‡Š
- ä¸­è‹±æ–‡æ³¨é‡Šæ··æ‚

### 23. é”™è¯¯ç è§„èŒƒåŒ–

- ä½¿ç”¨å­—ç¬¦ä¸²è¡¨ç¤ºé”™è¯¯ï¼ˆErrWrongLeaderï¼‰
- å»ºè®®ä½¿ç”¨æšä¸¾ç±»å‹

### 24-32. å…¶ä»–ä½ä¼˜å…ˆçº§æ”¹è¿›

- æ–‡æ¡£å®Œå–„
- æ€§èƒ½ç›‘æ§æ·»åŠ 
- æ—¥å¿—çº§åˆ«æ§åˆ¶
- é…ç½®çƒ­æ›´æ–°
- ä¼˜é›…å…³é—­
- ç­‰ç­‰...

---

## ğŸ“Š æ”¹è¿›ä¼˜å…ˆçº§è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼ˆç«‹å³æ‰§è¡Œï¼‰- P0 æ”¹è¿›

```
Week 1-2:
1. âœ… ä¿®å¤ LockQueue çš„é˜»å¡é—®é¢˜
2. âœ… ä¿®å¤ sleepNMilliseconds
3. âœ… ç¡®è®¤ raft ticker å‡½æ•°åœ¨åç¨‹ç¯å¢ƒè¿è¡Œ
4. âœ… ä¼˜åŒ– kvServer sleep

é¢„æœŸæ•ˆæœ: æ€§èƒ½æå‡ 100-200%
```

### ç¬¬äºŒé˜¶æ®µï¼ˆçŸ­æœŸï¼‰- P1 æ”¹è¿›

```
Week 3-4:
5. âœ… SkipList æ”¹ä¸ºè¯»å†™é”
6. âœ… kvServer é”åˆ†ç¦»
7. âœ… ConnectionPool ä¼˜åŒ–
8. âœ… Raft é”ä¼˜åŒ–

é¢„æœŸæ•ˆæœ: ååé‡å†æå‡ 50-100%
```

### ç¬¬ä¸‰é˜¶æ®µï¼ˆä¸­æœŸï¼‰- P2 æ”¹è¿›

```
Week 5-8:
9. âœ… ä»£ç é‡æ„å’Œä¼˜åŒ–
10. âœ… æµ‹è¯•è¦†ç›–æå‡
11. âœ… æ–‡æ¡£å®Œå–„
12. âœ… ç›‘æ§ç³»ç»Ÿæ·»åŠ 

é¢„æœŸæ•ˆæœ: ç³»ç»Ÿç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§æå‡
```

---

## ğŸ“ˆ é¢„æœŸæ€»ä½“æå‡

### æ€§èƒ½æå‡é¢„ä¼°

| åœºæ™¯ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| **ä½å¹¶å‘ï¼ˆ10ï¼‰** | åŸºå‡† | 1.5-2x | +50-100% |
| **ä¸­å¹¶å‘ï¼ˆ100ï¼‰** | åŸºå‡† | 3-5x | +200-400% |
| **é«˜å¹¶å‘ï¼ˆ1000ï¼‰** | åŸºå‡† | 5-10x | +400-900% |

### å…³é”®æŒ‡æ ‡æ”¹å–„

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æ”¹å–„ |
|------|--------|--------|------|
| **ååé‡** | 11,594 ops/s | 40,000-80,000 ops/s | **3-7å€** |
| **P99å»¶è¿Ÿ** | é¢„ä¼° 50ms | é¢„ä¼° 15-25ms | **-50%~-70%** |
| **CPUåˆ©ç”¨ç‡** | 60% | 80-90% | **+33%** |
| **çº¿ç¨‹é˜»å¡** | é«˜ | ä½ | **-90%** |

---

## ğŸ”§ å®æ–½å»ºè®®

### 1. ç«‹å³å¼€å§‹

```bash
# åˆ›å»ºæ”¹è¿›åˆ†æ”¯
git checkout -b feature/performance-improvements

# æŒ‰ä¼˜å…ˆçº§é€ä¸ªå®æ–½
# æ¯ä¸ªæ”¹è¿›ç‹¬ç«‹æäº¤ï¼Œæ–¹ä¾¿å›æ»š
```

### 2. æµ‹è¯•ç­–ç•¥

```cpp
// æ¯ä¸ªæ”¹è¿›åéƒ½è¦è¿è¡Œå®Œæ•´æµ‹è¯•
./comprehensive_performance_test.sh

// å¯¹æ¯”æ”¹è¿›å‰åçš„æ€§èƒ½æ•°æ®
```

### 3. é£é™©æ§åˆ¶

- æ¯ä¸ªæ”¹è¿›ç‹¬ç«‹åˆ†æ”¯
- å……åˆ†æµ‹è¯•åå†åˆå¹¶
- ä¿ç•™æ€§èƒ½åŸºå‡†æ•°æ®

---

## ğŸ“ é™„å½•

### A. ä»£ç å®¡æŸ¥æ¸…å•

- [ ] LockQueue æ”¹ä¸ºåç¨‹å‹å¥½
- [ ] sleepNMilliseconds ä¿®å¤
- [ ] Raft ticker å‡½æ•°ç¡®è®¤
- [ ] kvServer sleep ä¼˜åŒ–
- [ ] SkipList è¯»å†™é”
- [ ] kvServer é”åˆ†ç¦»
- [ ] ConnectionPool åˆ†æ®µé”
- [ ] å…¶ä»–æ”¹è¿›...

### B. æ€§èƒ½æµ‹è¯•æ¸…å•

- [ ] åŸºå‡†æµ‹è¯•ï¼ˆæ”¹è¿›å‰ï¼‰
- [ ] å•é¡¹æ”¹è¿›æµ‹è¯•
- [ ] ç»¼åˆæ”¹è¿›æµ‹è¯•
- [ ] å‹åŠ›æµ‹è¯•
- [ ] ç¨³å®šæ€§æµ‹è¯•

### C. ç›¸å…³æ–‡æ¡£

- [æµ‹è¯•æŠ¥å‘Š.md](./æµ‹è¯•æŠ¥å‘Š.md)
- [FINAL_PERFORMANCE_ANALYSIS_REPORT.md](./FINAL_PERFORMANCE_ANALYSIS_REPORT.md)
- [CHANGES_SUMMARY_TASK23.md](./CHANGES_SUMMARY_TASK23.md)

---

## ğŸ¯ ç»“è®º

é€šè¿‡æœ¬æŠ¥å‘Šè¯†åˆ«çš„ **32å¤„æ”¹è¿›ç‚¹**ï¼Œé¢„è®¡å¯ä»¥å°†ç³»ç»Ÿæ€§èƒ½æå‡ **3-10å€**ï¼ˆå–å†³äºå¹¶å‘åœºæ™¯ï¼‰ã€‚

**æœ€å…³é”®çš„ P0 æ”¹è¿›é¡¹**ï¼ˆLockQueueã€sleepNMillisecondsã€raft ticker ç¡®è®¤ã€kvServer sleepï¼‰åº”è¯¥**ç«‹å³å®æ–½**ï¼Œè¿™äº›æ”¹è¿›å¯ä»¥å¸¦æ¥ **100-200%** çš„æ€§èƒ½æå‡ï¼Œä¸”**é£é™©è¾ƒä½**ã€‚

å»ºè®®æŒ‰ç…§æœ¬æŠ¥å‘Šçš„ä¼˜å…ˆçº§è·¯çº¿å›¾ï¼Œ**åˆ†é˜¶æ®µå®æ–½**ï¼Œæ¯ä¸ªé˜¶æ®µéƒ½è¿›è¡Œå……åˆ†æµ‹è¯•ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§ã€‚

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2025å¹´10æœˆ28æ—¥  
**æŠ¥å‘Šç‰ˆæœ¬**: v1.0  
**å®¡æŸ¥èŒƒå›´**: å…¨ä»£ç åº“  
**æ”¹è¿›é¡¹æ€»æ•°**: 32ä¸ª

**è¿™æ˜¯ä¸€ä¸ªç»è¿‡è¯¦ç»†åˆ†æçš„æ€§èƒ½æå‡æ–¹æ¡ˆï¼** ğŸš€

