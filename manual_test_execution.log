===============================================================================
         手动Perf测试 - 分层分析
===============================================================================

[1] 启动RAFT集群...
  节点0 PID: 1337241
  节点1 PID: 1337242
  等待Leader选举 (10秒)...

[2] 测试网络层 (30秒perf采样)...
  启动客户端产生网络流量...
  开始perf record...

 Usage: perf record [<options>] [<command>]
    or: perf record [<options>] -- <command> [<options>]

    -a, --all-cpus        system-wide collection from all CPUs
    -b, --branch-any      sample any taken branches
    -B, --no-buildid      do not collect buildids in perf.data
    -c, --count <n>       event period to sample
    -C, --cpu <cpu>       list of cpus to monitor
    -d, --data            Record the sample addresses
    -D, --delay <n>       ms to wait before starting measurement after program start (-1: start with events disabled)
    -e, --event <event>   event selector. use 'perf list' to list available events
    -F, --freq <freq or 'max'>
                          profile at this frequency
    -g                    enables call-graph recording
    -G, --cgroup <name>   monitor event in cgroup name only
    -I, --intr-regs[=<any register>]
                          sample selected machine registers on interrupt, use '-I?' to list register names
    -i, --no-inherit      child tasks do not inherit counters
    -j, --branch-filter <branch filter mask>
                          branch stack filter modes
    -k, --clockid <clockid>
                          clockid to use for events, see clock_gettime()
    -m, --mmap-pages <pages[,pages]>
                          number of mmap data pages and AUX area tracing mmap pages
    -N, --no-buildid-cache
                          do not update the buildid cache
    -n, --no-samples      don't sample
    -o, --output <file>   output file name
    -P, --period          Record the sample period
    -p, --pid <pid>       record events on existing process id
    -q, --quiet           don't print any message
    -R, --raw-samples     collect raw sample records from all opened counters
    -r, --realtime <n>    collect data with this RT SCHED_FIFO priority
    -S, --snapshot[=<opts>]
                          AUX area tracing Snapshot Mode
    -s, --stat            per thread counts
    -t, --tid <tid>       record events on existing thread id
    -T, --timestamp       Record the sample timestamps
    -u, --uid <user>      user to profile
    -v, --verbose         be more verbose (show counter open errors, etc)
    -W, --weight          sample by weight (on special events only)
        --affinity <node|cpu>
                          Set affinity mask of trace reading thread to NUMA node cpu mask or cpu of processed mmap buffer
        --aio[=<n>]       Use <n> control blocks in asynchronous trace writing mode (default: 1, max: 4)
        --all-cgroups     Record cgroup events
        --all-kernel      Configure all used events to run in kernel space.
        --all-user        Configure all used events to run in user space.
        --aux-sample[=<opts>]
                          sample AUX area
        --buildid-all     Record build-id of all DSOs regardless of hits
        --buildid-mmap    Record build-id in map events
        --call-graph <record_mode[,record_size]>
                          setup and enables call-graph (stack chain/backtrace):

				record_mode:	call graph recording mode (fp|dwarf|lbr)
				record_size:	if record_mode is 'dwarf', max size of stack recording (<bytes>)
						default: 8192 (bytes)

				Default: fp
        --clang-opt <clang options>
                          options passed to clang when compiling BPF scriptlets
        --clang-path <clang path>
                          clang binary to use for compiling BPF scriptlets
        --code-page-size  Record the sampled code address (ip) page size
        --control <fd:ctl-fd[,ack-fd] or fifo:ctl-fifo[,ack-fifo]>
                          Listen on ctl-fd descriptor for command to control measurement ('enable': enable events, 'disable': disable events,
			  'snapshot': AUX area tracing snapshot).
			  Optionally send control command completion ('ack\n') to ack-fd descriptor.
			  Alternatively, ctl-fifo / ack-fifo will be opened and used as ctl-fd / ack-fd.
        --data-page-size  Record the sampled data address data page size
        --dry-run         Parse options then exit
        --exclude-perf    don't record events from perf itself
        --filter <filter>
                          event filter
        --group           put the counters into a counter group
        --kcore           copy /proc/kcore
        --kernel-callchains
                          collect kernel callchains
        --max-size <size>
                          Limit the maximum size of the output file
        --mmap-flush <number>
                          Minimal number of bytes that is extracted from mmap data pages (default: 1)
        --namespaces      Record namespaces events
        --no-bpf-event    do not record bpf events
        --no-buffering    collect data without buffering
        --num-thread-synthesize <n>
                          number of threads to run for event synthesis
        --overwrite       use overwrite mode
        --per-thread      use per-thread mmaps
        --phys-data       Record the sample physical addresses
        --proc-map-timeout <n>
                          per thread proc mmap processing timeout in ms
        --running-time    Record running/enabled time of read (:S) events
        --sample-cpu      Record the sample cpu
        --strict-freq     Fail if the specified frequency can't be used
        --switch-events   Record context switch events
        --switch-max-files <n>
                          Limit number of switch output generated files
        --switch-output[=<signal or size[BKMG] or time[smhd]>]
                          Switch output when receiving SIGUSR2 (signal) or cross a size or time threshold
        --switch-output-event <switch output event>
                          switch output event selector. use 'perf list' to list available events
        --tail-synthesize
                          synthesize non-sample events at the end of output
        --timestamp-boundary
                          Record timestamp boundary (time of first/last samples)
        --timestamp-filename
                          append timestamp to output filename
        --transaction     sample transaction flags (special events only)
        --user-callchains
                          collect user callchains
        --user-regs[=<any register>]
                          sample selected machine registers in user space, use '--user-regs=?' to list register names
        --vmlinux <file>  vmlinux pathname

  ✓ perf采样完成
  生成报告...
  生成火焰图...
Stack count is low (0). Did something go wrong?
ERROR: No stack counts found
  ✓ 网络层测试完成

[3] 测试日志I/O层 (30秒perf采样)...
  启动客户端产生大量写入...
  开始perf record...

 Usage: perf record [<options>] [<command>]
    or: perf record [<options>] -- <command> [<options>]

    -a, --all-cpus        system-wide collection from all CPUs
    -b, --branch-any      sample any taken branches
    -B, --no-buildid      do not collect buildids in perf.data
    -c, --count <n>       event period to sample
    -C, --cpu <cpu>       list of cpus to monitor
    -d, --data            Record the sample addresses
    -D, --delay <n>       ms to wait before starting measurement after program start (-1: start with events disabled)
    -e, --event <event>   event selector. use 'perf list' to list available events
    -F, --freq <freq or 'max'>
                          profile at this frequency
    -g                    enables call-graph recording
    -G, --cgroup <name>   monitor event in cgroup name only
    -I, --intr-regs[=<any register>]
                          sample selected machine registers on interrupt, use '-I?' to list register names
    -i, --no-inherit      child tasks do not inherit counters
    -j, --branch-filter <branch filter mask>
                          branch stack filter modes
    -k, --clockid <clockid>
                          clockid to use for events, see clock_gettime()
    -m, --mmap-pages <pages[,pages]>
                          number of mmap data pages and AUX area tracing mmap pages
    -N, --no-buildid-cache
                          do not update the buildid cache
    -n, --no-samples      don't sample
    -o, --output <file>   output file name
    -P, --period          Record the sample period
    -p, --pid <pid>       record events on existing process id
    -q, --quiet           don't print any message
    -R, --raw-samples     collect raw sample records from all opened counters
    -r, --realtime <n>    collect data with this RT SCHED_FIFO priority
    -S, --snapshot[=<opts>]
                          AUX area tracing Snapshot Mode
    -s, --stat            per thread counts
    -t, --tid <tid>       record events on existing thread id
    -T, --timestamp       Record the sample timestamps
    -u, --uid <user>      user to profile
    -v, --verbose         be more verbose (show counter open errors, etc)
    -W, --weight          sample by weight (on special events only)
        --affinity <node|cpu>
                          Set affinity mask of trace reading thread to NUMA node cpu mask or cpu of processed mmap buffer
        --aio[=<n>]       Use <n> control blocks in asynchronous trace writing mode (default: 1, max: 4)
        --all-cgroups     Record cgroup events
        --all-kernel      Configure all used events to run in kernel space.
        --all-user        Configure all used events to run in user space.
        --aux-sample[=<opts>]
                          sample AUX area
        --buildid-all     Record build-id of all DSOs regardless of hits
        --buildid-mmap    Record build-id in map events
        --call-graph <record_mode[,record_size]>
                          setup and enables call-graph (stack chain/backtrace):

				record_mode:	call graph recording mode (fp|dwarf|lbr)
				record_size:	if record_mode is 'dwarf', max size of stack recording (<bytes>)
						default: 8192 (bytes)

				Default: fp
        --clang-opt <clang options>
                          options passed to clang when compiling BPF scriptlets
        --clang-path <clang path>
                          clang binary to use for compiling BPF scriptlets
        --code-page-size  Record the sampled code address (ip) page size
        --control <fd:ctl-fd[,ack-fd] or fifo:ctl-fifo[,ack-fifo]>
                          Listen on ctl-fd descriptor for command to control measurement ('enable': enable events, 'disable': disable events,
			  'snapshot': AUX area tracing snapshot).
			  Optionally send control command completion ('ack\n') to ack-fd descriptor.
			  Alternatively, ctl-fifo / ack-fifo will be opened and used as ctl-fd / ack-fd.
        --data-page-size  Record the sampled data address data page size
        --dry-run         Parse options then exit
        --exclude-perf    don't record events from perf itself
        --filter <filter>
                          event filter
        --group           put the counters into a counter group
        --kcore           copy /proc/kcore
        --kernel-callchains
                          collect kernel callchains
        --max-size <size>
                          Limit the maximum size of the output file
        --mmap-flush <number>
                          Minimal number of bytes that is extracted from mmap data pages (default: 1)
        --namespaces      Record namespaces events
        --no-bpf-event    do not record bpf events
        --no-buffering    collect data without buffering
        --num-thread-synthesize <n>
                          number of threads to run for event synthesis
        --overwrite       use overwrite mode
        --per-thread      use per-thread mmaps
        --phys-data       Record the sample physical addresses
        --proc-map-timeout <n>
                          per thread proc mmap processing timeout in ms
        --running-time    Record running/enabled time of read (:S) events
        --sample-cpu      Record the sample cpu
        --strict-freq     Fail if the specified frequency can't be used
        --switch-events   Record context switch events
        --switch-max-files <n>
                          Limit number of switch output generated files
        --switch-output[=<signal or size[BKMG] or time[smhd]>]
                          Switch output when receiving SIGUSR2 (signal) or cross a size or time threshold
        --switch-output-event <switch output event>
                          switch output event selector. use 'perf list' to list available events
        --tail-synthesize
                          synthesize non-sample events at the end of output
        --timestamp-boundary
                          Record timestamp boundary (time of first/last samples)
        --timestamp-filename
                          append timestamp to output filename
        --transaction     sample transaction flags (special events only)
        --user-callchains
                          collect user callchains
        --user-regs[=<any register>]
                          sample selected machine registers in user space, use '--user-regs=?' to list register names
        --vmlinux <file>  vmlinux pathname

  ✓ perf采样完成
  生成报告...
  生成火焰图...
Stack count is low (0). Did something go wrong?
ERROR: No stack counts found
  ✓ 日志I/O层测试完成

[4] 测试共识层 (30秒perf采样 - 双节点)...
  启动客户端产生混合请求...
  开始perf record节点0...
  开始perf record节点1...

 Usage: perf record [<options>] [<command>]
    or: perf record [<options>] -- <command> [<options>]

    -a, --all-cpus        system-wide collection from all CPUs
    -b, --branch-any      sample any taken branches
    -B, --no-buildid      do not collect buildids in perf.data
    -c, --count <n>       event period to sample
    -C, --cpu <cpu>       list of cpus to monitor
    -d, --data            Record the sample addresses
    -D, --delay <n>       ms to wait before starting measurement after program start (-1: start with events disabled)
    -e, --event <event>   event selector. use 'perf list' to list available events
    -F, --freq <freq or 'max'>
                          profile at this frequency
    -g                    enables call-graph recording
    -G, --cgroup <name>   monitor event in cgroup name only
    -I, --intr-regs[=<any register>]
                          sample selected machine registers on interrupt, use '-I?' to list register names
    -i, --no-inherit      child tasks do not inherit counters
    -j, --branch-filter <branch filter mask>
                          branch stack filter modes
    -k, --clockid <clockid>
                          clockid to use for events, see clock_gettime()
    -m, --mmap-pages <pages[,pages]>
                          number of mmap data pages and AUX area tracing mmap pages
    -N, --no-buildid-cache
                          do not update the buildid cache
    -n, --no-samples      don't sample
    -o, --output <file>   output file name
    -P, --period          Record the sample period
    -p, --pid <pid>       record events on existing process id
    -q, --quiet           don't print any message
    -R, --raw-samples     collect raw sample records from all opened counters
    -r, --realtime <n>    collect data with this RT SCHED_FIFO priority
    -S, --snapshot[=<opts>]
                          AUX area tracing Snapshot Mode
    -s, 
 Usage: perf record [<options>] [<command>]
--stat    or: perf record [<options>] -- <command> [<options>]
            per thread counts
    
-t, --tid <tid>       record events on existing thread id
    -T, --timestamp       Record the sample timestamps
    -u, --uid <user>      user to profile
    -v, --verbose         be more verbose (show counter open errors, etc)
    -W, --weight          sample by weight (on special events only)
        --affinity <node|cpu>
                          Set affinity mask of trace reading thread to NUMA node cpu mask or cpu of processed mmap buffer
        --aio[=<n>]       Use <n> control blocks in asynchronous trace writing mode (default: 1, max: 4)
        --all-cgroups     Record cgroup events
        --all-kernel      Configure all used events to run in kernel space.
            -a--all-user,         Configure all used events to run in user space.
--all-cpus        --aux-sample        system-wide collection from all CPUs
[=<opts>]    
-b                          sample AUX area
,     --branch-any    --buildid-all      sample any taken branches
     Record build-id of all DSOs regardless of hits
            -B--buildid-mmap,     Record build-id in map events
--no-buildid          do not collect buildids in perf.data
        --call-graph-c,  <record_mode[,record_size]>--count
 <n>       event period to sample
    -C, --cpu <cpu>       list of cpus to monitor
    -d,                           setup and enables call-graph (stack chain/backtrace):

				record_mode:	call graph recording mode (fp|dwarf|lbr)
				record_size:	if record_mode is 'dwarf', max size of stack recording (<bytes>)
						default: 8192 (bytes)

				Default: fp
--data                Record the sample addresses
        --clang-opt-D <clang options>, 
--delay                          options passed to clang when compiling BPF scriptlets
 <n>               ms to wait before starting measurement after program start (-1: start with events disabled)
--clang-path     <clang path>-e
,                           clang binary to use for compiling BPF scriptlets
--event     <event>       event selector. use 'perf list' to list available events
--code-page-size      Record the sampled code address (ip) page size
-F    ,     --freq--control <freq or 'max'> <fd:ctl-fd[,ack-fd] or fifo:ctl-fifo[,ack-fifo]>

                          profile at this frequency
                              Listen on ctl-fd descriptor for command to control measurement ('enable': enable events, 'disable': disable events,
			  'snapshot': AUX area tracing snapshot).
			  Optionally send control command completion ('ack\n') to ack-fd descriptor.
			  Alternatively, ctl-fifo / ack-fifo will be opened and used as ctl-fd / ack-fd.
-g                        enables call-graph recording
        --data-page-size-G  Record the sampled data address data page size
,     --cgroup     <name>--dry-run         Parse options then exit
   monitor event in cgroup name only
            -I--exclude-perf,     don't record events from perf itself
--intr-regs    [=<any register>]    
--filter                          sample selected machine registers on interrupt, use '-I?' to list register names
 <filter>    
-i                          event filter
,     --no-inherit          child tasks do not inherit counters
--group               put the counters into a counter group
-j    , --branch-filter     <branch filter mask>--kcore
           copy /proc/kcore
                          branch stack filter modes
            -k--kernel-callchains, 
--clockid                          collect kernel callchains
     <clockid>    
--max-size                          clockid to use for events, see clock_gettime()
 <size>    
-m                          Limit the maximum size of the output file
,     --mmap-pages     <pages[,pages]>--mmap-flush
 <number>                          number of mmap data pages and AUX area tracing mmap pages

                              Minimal number of bytes that is extracted from mmap data pages (default: 1)
-N    ,     --no-buildid-cache--namespaces
      Record namespaces events
                          do not update the buildid cache
        -n    , --no-bpf-event--no-samples    do not record bpf events
      don't sample
            -o--no-buffering,     collect data without buffering
    --output     <file>--num-thread-synthesize   output file name
 <n>    
-P                          number of threads to run for event synthesis
,     --period              Record the sample period
--overwrite           use overwrite mode
-p    ,     --pid--per-thread <pid>      use per-thread mmaps
       record events on existing process id
            -q, --phys-data--quiet       Record the sample physical addresses
           don't print any message
            -R--proc-map-timeout,  <n>--raw-samples
     collect raw sample records from all opened counters
                          per thread proc mmap processing timeout in ms
            -r--running-time,     Record running/enabled time of read (:S) events
--realtime     <n>        collect data with this RT SCHED_FIFO priority
--sample-cpu          Record the sample cpu
-S    ,     --snapshot--strict-freq[=<opts>]     Fail if the specified frequency can't be used

                              AUX area tracing Snapshot Mode
        --switch-events-s   Record context switch events
, --stat                per thread counts
        --switch-max-files-t <n>, 
--tid                          Limit number of switch output generated files
 <tid>           record events on existing thread id
    --switch-output    [=<signal or size[BKMG] or time[smhd]>]-T
,                           Switch output when receiving SIGUSR2 (signal) or cross a size or time threshold
--timestamp           Record the sample timestamps
        --switch-output-event-u <switch output event>, 
--uid                          switch output event selector. use 'perf list' to list available events
 <user>          user to profile
        --tail-synthesize-v
,                           synthesize non-sample events at the end of output
--verbose             be more verbose (show counter open errors, etc)
        -W--timestamp-boundary, 
--weight                          Record timestamp boundary (time of first/last samples)
          sample by weight (on special events only)
                --timestamp-filename--affinity
                          append timestamp to output filename
 <node|cpu>    
                              Set affinity mask of trace reading thread to NUMA node cpu mask or cpu of processed mmap buffer
--transaction         sample transaction flags (special events only)
        --aio    [=<n>]--user-callchains
       Use <n> control blocks in asynchronous trace writing mode (default: 1, max: 4)
                          collect user callchains
                --all-cgroups--user-regs     Record cgroup events
[=<any register>]    
                              sample selected machine registers in user space, use '--user-regs=?' to list register names
--all-kernel      Configure all used events to run in kernel space.
                --vmlinux--all-user <file>        Configure all used events to run in user space.
  vmlinux pathname
    
    --aux-sample[=<opts>]
                          sample AUX area
        --buildid-all     Record build-id of all DSOs regardless of hits
        --buildid-mmap    Record build-id in map events
        --call-graph <record_mode[,record_size]>
                          setup and enables call-graph (stack chain/backtrace):

				record_mode:	call graph recording mode (fp|dwarf|lbr)
				record_size:	if record_mode is 'dwarf', max size of stack recording (<bytes>)
						default: 8192 (bytes)

				Default: fp
        --clang-opt <clang options>
                          options passed to clang when compiling BPF scriptlets
        --clang-path <clang path>
                          clang binary to use for compiling BPF scriptlets
        --code-page-size  Record the sampled code address (ip) page size
        --control <fd:ctl-fd[,ack-fd] or fifo:ctl-fifo[,ack-fifo]>
                          Listen on ctl-fd descriptor for command to control measurement ('enable': enable events, 'disable': disable events,
			  'snapshot': AUX area tracing snapshot).
			  Optionally send control command completion ('ack\n') to ack-fd descriptor.
			  Alternatively, ctl-fifo / ack-fifo will be opened and used as ctl-fd / ack-fd.
        --data-page-size  Record the sampled data address data page size
        --dry-run         Parse options then exit
        --exclude-perf    don't record events from perf itself
        --filter <filter>
                          event filter
        --group           put the counters into a counter group
        --kcore           copy /proc/kcore
        --kernel-callchains
                          collect kernel callchains
        --max-size <size>
                          Limit the maximum size of the output file
        --mmap-flush <number>
                          Minimal number of bytes that is extracted from mmap data pages (default: 1)
        --namespaces      Record namespaces events
        --no-bpf-event    do not record bpf events
        --no-buffering    collect data without buffering
        --num-thread-synthesize <n>
                          number of threads to run for event synthesis
        --overwrite       use overwrite mode
        --per-thread      use per-thread mmaps
        --phys-data       Record the sample physical addresses
        --proc-map-timeout <n>
                          per thread proc mmap processing timeout in ms
        --running-time    Record running/enabled time of read (:S) events
        --sample-cpu      Record the sample cpu
        --strict-freq     Fail if the specified frequency can't be used
        --switch-events   Record context switch events
        --switch-max-files <n>
                          Limit number of switch output generated files
        --switch-output[=<signal or size[BKMG] or time[smhd]>]
                          Switch output when receiving SIGUSR2 (signal) or cross a size or time threshold
        --switch-output-event <switch output event>
                          switch output event selector. use 'perf list' to list available events
        --tail-synthesize
                          synthesize non-sample events at the end of output
        --timestamp-boundary
                          Record timestamp boundary (time of first/last samples)
        --timestamp-filename
                          append timestamp to output filename
        --transaction     sample transaction flags (special events only)
        --user-callchains
                          collect user callchains
        --user-regs[=<any register>]
                          sample selected machine registers in user space, use '--user-regs=?' to list register names
        --vmlinux <file>  vmlinux pathname

  ✓ perf采样完成
  生成节点0报告...
Stack count is low (0). Did something go wrong?
ERROR: No stack counts found
  生成节点1报告...
Stack count is low (0). Did something go wrong?
ERROR: No stack counts found
  ✓ 共识层测试完成

[5] 测试系统调用 (30秒strace)...
  启动客户端产生大量写入...
  开始strace...
  ✓ strace完成

[6] 分析Persister数据...

[7] 停止集群...

===============================================================================
                    测试完成！
===============================================================================

📊 结果目录: manual_test_results/

📄 主要文件:
  网络层:
    - manual_test_results/network_perf_report.txt
    - manual_test_results/network_flamegraph.svg
  日志I/O层:
    - manual_test_results/log_io_perf_report.txt
    - manual_test_results/log_io_flamegraph.svg
  共识层:
    - manual_test_results/consensus_node0_report.txt
    - manual_test_results/consensus_node0_flamegraph.svg
    - manual_test_results/consensus_node1_report.txt
    - manual_test_results/consensus_node1_flamegraph.svg
  系统调用:
    - manual_test_results/strace_node0.txt

===============================================================================
