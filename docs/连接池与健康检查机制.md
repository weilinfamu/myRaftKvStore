# 连接池与健康检查机制 - 技术文档

## 概述

本文档详细介绍了 RPC 系统的连接管理增强功能，包括：
1. **ConnectionPool 连接池**：高效管理和复用 RPC 连接
2. **连接状态机**：HEALTHY → PROBING → DISCONNECTED 三态管理
3. **心跳机制**：自动检测和维护连接健康
4. **动态接收缓冲区**：正确处理任意大小的 RPC 响应

## 一、ConnectionPool 连接池

### 1.1 设计目标

解决原有实现的问题：
- ❌ 假定连接永远存活（不现实）
- ❌ 每次调用可能创建新连接（低效）
- ❌ 没有连接健康检查机制
- ❌ 连接断开后无法自动恢复

新的连接池实现：
- ✅ 自动管理连接的创建、复用和销毁
- ✅ 主动探测连接健康状况
- ✅ 自动丢弃不健康的连接
- ✅ 提供连接池统计信息

### 1.2 核心数据结构

```cpp
class ConnectionPool {
private:
    // 核心数据结构：map<"ip:port", queue<连接>>
    std::map<std::string, std::queue<std::shared_ptr<MprpcChannel>>> pools_;
    
    // 保护连接池的互斥锁
    std::mutex mutex_;
    
    // 统计信息
    std::atomic<uint64_t> total_connections_created_;
    std::atomic<uint64_t> total_connections_reused_;
    std::atomic<uint64_t> total_connections_discarded_;
};
```

**设计要点**：
- **按地址分组**：不同目标地址有独立的连接队列
- **线程安全**：使用互斥锁保护共享数据
- **统计信息**：跟踪连接创建、复用、丢弃的次数

### 1.3 主要接口

#### GetConnection(ip, port)

```cpp
std::shared_ptr<MprpcChannel> GetConnection(const std::string& ip, uint16_t port);
```

**工作流程**：
```
1. 生成 key = "ip:port"
2. 查找对应地址的连接池
3. 如果池中有连接：
   a. 取出一个连接
   b. 检查连接是否健康（IsHealthy()）
   c. 如果健康，返回连接（复用）
   d. 如果不健康，丢弃并创建新连接
4. 如果池为空：
   a. 创建新连接
   b. 返回新连接
```

**示例**：
```cpp
auto& pool = ConnectionPool::GetInstance();
auto channel = pool.GetConnection("192.168.1.100", 8080);

if (channel && channel->IsHealthy()) {
    // 使用连接进行 RPC 调用
}
```

#### ReturnConnection(channel, ip, port)

```cpp
void ReturnConnection(std::shared_ptr<MprpcChannel> channel, 
                     const std::string& ip, uint16_t port);
```

**工作流程**：
```
1. 检查连接是否为空
2. 检查连接是否健康（IsHealthy()）
3. 如果健康：
   a. 放回对应地址的连接池
   b. 供后续复用
4. 如果不健康：
   a. 直接丢弃（不放回池中）
   b. 增加丢弃计数
```

**示例**：
```cpp
// RPC 调用完成后
pool.ReturnConnection(channel, "192.168.1.100", 8080);

// 只有健康的连接才会被放回池中
// 不健康的连接会被自动丢弃
```

### 1.4 使用模式

#### 模式 1：手动管理

```cpp
void MyRpcCall() {
    auto& pool = ConnectionPool::GetInstance();
    
    // 获取连接
    auto channel = pool.GetConnection(ip, port);
    if (!channel) {
        // 处理错误
        return;
    }
    
    // 执行 RPC 调用
    YourService_Stub stub(channel.get());
    // ...
    
    // 归还连接
    pool.ReturnConnection(channel, ip, port);
}
```

#### 模式 2：RAII 自动管理（推荐）

```cpp
class ConnectionGuard {
public:
    ConnectionGuard(const std::string& ip, uint16_t port) 
        : ip_(ip), port_(port) {
        channel_ = ConnectionPool::GetInstance().GetConnection(ip, port);
    }
    
    ~ConnectionGuard() {
        if (channel_) {
            ConnectionPool::GetInstance().ReturnConnection(channel_, ip_, port_);
        }
    }
    
    std::shared_ptr<MprpcChannel> get() { return channel_; }
    
private:
    std::string ip_;
    uint16_t port_;
    std::shared_ptr<MprpcChannel> channel_;
};

// 使用
void MyRpcCall() {
    ConnectionGuard guard(ip, port);
    auto channel = guard.get();
    
    if (!channel) return;
    
    // 执行 RPC 调用
    // ...
    
    // guard 析构时自动归还连接
}
```

## 二、连接状态机

### 2.1 三态状态机

```
                 连接成功
    [初始] ─────────────────> [HEALTHY]
                                  │
                                  │ 调用失败
                                  ↓
                              [PROBING]
                                  │
                                  │ 失败次数 >= 3
                                  ↓
                            [DISCONNECTED]
```

#### 状态定义

```cpp
enum class ConnectionState {
    HEALTHY,      // 健康状态，连接正常工作
    PROBING,      // 探测状态，连接可能有问题，正在检测
    DISCONNECTED  // 断开状态，连接已失效
};
```

### 2.2 状态转换逻辑

#### HEALTHY → PROBING

**触发条件**：
- RPC 调用失败（send/recv 返回错误）
- 心跳检测失败

**动作**：
```cpp
void HandleFailure() {
    if (m_state == HEALTHY) {
        m_state = PROBING;
        m_failure_count = 1;
        ScheduleHeartbeat();  // 调度更短间隔的探测（5秒）
    }
}
```

#### PROBING → HEALTHY

**触发条件**：
- RPC 调用成功
- 心跳检测成功

**动作**：
```cpp
void HandleSuccess() {
    m_failure_count = 0;
    m_state = HEALTHY;
    ScheduleHeartbeat();  // 调度正常间隔的心跳（10秒）
}
```

#### PROBING → DISCONNECTED

**触发条件**：
- 连续失败次数 >= 3

**动作**：
```cpp
void HandleFailure() {
    if (m_state == PROBING) {
        m_failure_count++;
        if (m_failure_count >= MAX_FAILURE_COUNT) {  // 3次
            m_state = DISCONNECTED;
            CancelHeartbeat();
            close(m_clientFd);
            m_clientFd = -1;
        }
    }
}
```

### 2.3 状态查询

```cpp
// 检查连接是否健康
bool is_healthy = channel->IsHealthy();  // state == HEALTHY

// 检查连接是否已断开
bool is_disconnected = channel->IsDisconnected();  // state == DISCONNECTED

// 获取当前状态
ConnectionState state = channel->GetState();
```

## 三、心跳机制

### 3.1 设计原理

**为什么需要心跳？**
- TCP 连接可能"半开"：一端已断开，另一端不知道
- 网络中间设备可能关闭空闲连接
- 服务端可能崩溃或重启

**心跳机制**：
- 定期发送探测包检测连接是否仍然可用
- 在连接空闲时自动触发
- 失败时自动进入探测模式

### 3.2 时间参数

```cpp
// 配置参数
static constexpr uint64_t HEARTBEAT_INTERVAL_MS = 10000;  // 正常心跳间隔 10 秒
static constexpr uint64_t PROBE_INTERVAL_MS = 5000;       // 探测间隔 5 秒
static constexpr int MAX_FAILURE_COUNT = 3;                // 最大失败次数
```

**时间轴示例**：

```
时间轴（HEALTHY 状态）:
0s ────> 10s ────> 20s ────> 30s
  RPC调用  心跳检查  RPC调用  心跳检查
  重置定时器          重置定时器
  
时间轴（PROBING 状态）:
0s ──> 5s ──> 10s ──> 15s
 失败  探测  探测   探测
       失败1 失败2  失败3 → DISCONNECTED
```

### 3.3 心跳实现

#### 调度心跳

```cpp
void ScheduleHeartbeat() {
    auto iom = monsoon::IOManager::GetThis();
    if (!iom) return;  // 不在 IOManager 环境中
    
    CancelHeartbeat();  // 取消旧定时器
    
    // 根据状态选择间隔
    uint64_t interval_ms = (m_state == PROBING) ? 
                           PROBE_INTERVAL_MS : HEARTBEAT_INTERVAL_MS;
    
    // 使用 weak_ptr 避免循环引用
    std::weak_ptr<MprpcChannel> weak_self = shared_from_this();
    
    m_heartbeat_timer = iom->addTimer(interval_ms, [weak_self]() {
        auto self = weak_self.lock();
        if (self) {
            self->CheckIdleConnection();
        }
    });
}
```

#### 执行心跳检查

```cpp
void CheckIdleConnection() {
    bool success = SendHeartbeat();
    
    if (success) {
        HandleSuccess();  // 重置失败计数，保持 HEALTHY
    } else {
        HandleFailure();  // 增加失败计数，可能进入 PROBING/DISCONNECTED
    }
}
```

#### 发送心跳包

```cpp
bool SendHeartbeat() {
    if (m_clientFd == -1) {
        return false;
    }
    
    // 发送一个空数据包（仅用于探测）
    char dummy = 0;
    ssize_t ret = send(m_clientFd, &dummy, 0, MSG_NOSIGNAL);
    
    if (ret == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
        return false;  // 心跳失败
    }
    
    return true;  // 心跳成功
}
```

### 3.4 心跳与 RPC 调用的配合

```cpp
void CallMethod(...) {
    // 执行 RPC 调用
    // ...
    
    if (success) {
        HandleSuccess();  // 调用成功时：
                          // 1. 重置失败计数
                          // 2. 更新最后活跃时间
                          // 3. 重新调度心跳（10秒后）
    } else {
        HandleFailure();  // 调用失败时：
                          // 1. 增加失败计数
                          // 2. 可能进入 PROBING 状态
                          // 3. 调度更短的探测（5秒后）
    }
}
```

**关键点**：
- 每次成功的 RPC 调用都会重置心跳定时器
- 这样，活跃的连接不会频繁心跳
- 只有空闲的连接才会触发心跳检测

## 四、动态接收缓冲区

### 4.1 问题分析

**原有实现的问题**：

```cpp
// 旧代码 - 有严重缺陷
char recv_buf[1024] = {0};  // 固定 1024 字节
int recv_size = recv(m_clientFd, recv_buf, 1024, 0);

// 问题：
// 1. 响应 > 1024 字节时会截断
// 2. 无法处理大数据（如文件传输）
// 3. 违反了 RPC 协议的设计
```

**RPC 协议格式**：

```
发送格式:
┌─────────────┬──────────────┬───────────────┐
│ Header Size │ Header Data  │ Payload Data  │
│ (Varint32)  │ (N bytes)    │ (M bytes)     │
└─────────────┴──────────────┴───────────────┘

Header 中包含:
- service_name
- method_name
- args_size (M)  ← 重要！payload 的实际大小
```

### 4.2 新的接收逻辑

#### 五步接收法

```cpp
void CallMethod(...) {
    // ========== 第一步：读取头部长度（变长编码）==========
    uint32_t header_size = 0;
    {
        uint8_t varint_buf[10] = {0};
        int varint_bytes = 0;
        
        // 逐字节读取变长编码
        for (int i = 0; i < 10; ++i) {
            recv(m_clientFd, &varint_buf[i], 1, 0);
            varint_bytes++;
            
            // 检查是否是最后一个字节（最高位为 0）
            if ((varint_buf[i] & 0x80) == 0) {
                break;
            }
        }
        
        // 解码变长整数
        google::protobuf::io::ArrayInputStream array_input(varint_buf, varint_bytes);
        google::protobuf::io::CodedInputStream coded_input(&array_input);
        coded_input.ReadVarint32(&header_size);
    }
    
    // ========== 第二步：读取头部内容 ==========
    std::vector<char> header_buf(header_size);  // 动态分配
    {
        size_t received = 0;
        while (received < header_size) {
            ssize_t ret = recv(m_clientFd, 
                              header_buf.data() + received, 
                              header_size - received, 0);
            received += ret;
        }
    }
    
    // ========== 第三步：反序列化头部 ==========
    RPC::RpcHeader resp_header;
    resp_header.ParseFromArray(header_buf.data(), header_size);
    
    // ========== 第四步：读取业务数据 ==========
    uint32_t response_args_size = resp_header.args_size();  // 从头部获取大小
    std::vector<char> response_buf(response_args_size);  // 动态分配
    {
        size_t received = 0;
        while (received < response_args_size) {
            ssize_t ret = recv(m_clientFd, 
                              response_buf.data() + received, 
                              response_args_size - received, 0);
            received += ret;
        }
    }
    
    // ========== 第五步：反序列化业务数据 ==========
    response->ParseFromArray(response_buf.data(), response_args_size);
}
```

### 4.3 关键改进

#### 改进 1：按协议分步读取

```
旧方式：一次性读 1024 字节（错误）
新方式：
  1. 读取头部大小 (N 字节)
  2. 读取头部内容 (N 字节)
  3. 从头部获取 payload 大小 (M)
  4. 读取 payload 内容 (M 字节)
```

#### 改进 2：动态缓冲区

```cpp
// 旧方式：固定大小
char buf[1024];

// 新方式：动态大小
std::vector<char> header_buf(header_size);      // 根据实际大小分配
std::vector<char> response_buf(args_size);      // 根据实际大小分配
```

#### 改进 3：循环读取直到完整

```cpp
// 确保读取完整数据
size_t received = 0;
while (received < expected_size) {
    ssize_t ret = recv(fd, buf + received, expected_size - received, 0);
    if (ret <= 0) {
        // 错误处理
        break;
    }
    received += ret;
}
```

**为什么需要循环**？
- `recv()` 可能返回部分数据
- 网络层可能分片传输
- 必须循环直到读满

### 4.4 性能考虑

#### 协程环境中的阻塞读取

```cpp
// 看起来是阻塞的循环读取
while (received < expected_size) {
    ssize_t ret = recv(fd, buf + received, expected_size - received, 0);
    received += ret;
}

// 实际上，Hook 机制会自动处理：
// 1. recv 被 Hook 拦截
// 2. 如果数据未到，协程 yield
// 3. 物理线程去执行其他协程
// 4. 数据到达时，协程恢复
// 
// 结果：看起来同步，实际异步，性能极高！
```

## 五、完整工作流程

### 5.1 第一次 RPC 调用

```
1. 调用 ConnectionPool::GetConnection()
   └─> 池为空，创建新连接
   └─> 调用 MprpcChannel 构造函数
       └─> m_state = HEALTHY
       └─> 调用 newConnect()
           └─> socket() + connect()
           └─> setsockopt(SO_RCVTIMEO, 5秒)
           └─> setsockopt(SO_SNDTIMEO, 5秒)
       └─> ScheduleHeartbeat()  // 10秒后触发

2. 执行 RPC 调用
   └─> CallMethod()
       └─> 序列化请求
       └─> send() 发送（被 Hook 自动异步化）
       └─> recv() 接收（动态缓冲区，被 Hook 自动异步化）
           └─> 读取头部长度
           └─> 读取头部内容
           └─> 读取 payload 大小
           └─> 读取 payload 内容
       └─> 反序列化响应
       └─> HandleSuccess()
           └─> m_failure_count = 0
           └─> 重新 ScheduleHeartbeat()  // 重置为10秒后

3. 归还连接
   └─> ConnectionPool::ReturnConnection()
       └─> channel->IsHealthy() ? 放回池中 : 丢弃
```

### 5.2 复用连接

```
1. 调用 ConnectionPool::GetConnection()
   └─> 池中有连接，取出
   └─> 检查 IsHealthy()
       └─> 如果健康，直接返回（复用）
       └─> 如果不健康，丢弃并创建新连接

2. 执行 RPC 调用
   └─> （同上）

3. 归还连接
   └─> 放回池中供下次复用
```

### 5.3 故障恢复流程

```
1. RPC 调用失败（如网络闪断）
   └─> HandleFailure()
       └─> HEALTHY → PROBING
       └─> m_failure_count = 1
       └─> ScheduleHeartbeat(5秒后)

2. 5秒后，心跳检测
   └─> CheckIdleConnection()
       └─> SendHeartbeat()
           └─> 如果成功：PROBING → HEALTHY
           └─> 如果失败：m_failure_count++

3. 如果连续失败 3 次
   └─> PROBING → DISCONNECTED
   └─> close(fd)
   └─> CancelHeartbeat()

4. 下次调用时
   └─> ConnectionPool::GetConnection()
       └─> 检测到 IsDisconnected()
       └─> 丢弃旧连接
       └─> 创建新连接
```

## 六、配置与调优

### 6.1 可配置参数

```cpp
class MprpcChannel {
private:
    // 这些参数可以根据实际需求调整
    static constexpr int MAX_FAILURE_COUNT = 3;           // 最大失败次数
    static constexpr uint64_t HEARTBEAT_INTERVAL_MS = 10000;  // 心跳间隔
    static constexpr uint64_t PROBE_INTERVAL_MS = 5000;       // 探测间隔
};

// 在 newConnect() 中
struct timeval timeout;
timeout.tv_sec = 5;  // 超时时间
```

### 6.2 调优建议

#### 场景 1：高延迟网络

```cpp
// 增加超时时间
timeout.tv_sec = 10;  // 10秒超时

// 增加心跳间隔
HEARTBEAT_INTERVAL_MS = 30000;  // 30秒
```

#### 场景 2：不稳定网络

```cpp
// 增加失败容忍度
MAX_FAILURE_COUNT = 5;  // 允许失败 5 次

// 缩短探测间隔，快速恢复
PROBE_INTERVAL_MS = 3000;  // 3秒探测
```

#### 场景 3：局域网/稳定网络

```cpp
// 缩短心跳间隔，快速发现问题
HEARTBEAT_INTERVAL_MS = 5000;  // 5秒

// 减少失败容忍度
MAX_FAILURE_COUNT = 2;  // 失败 2 次即断开
```

## 七、性能分析

### 7.1 连接复用的收益

```
假设：
- 建立连接耗时：10ms
- RPC 调用耗时：5ms
- 1000 次调用

不使用连接池：
  1000 × (10ms + 5ms) = 15000ms = 15秒

使用连接池（复用）：
  1 × 10ms + 1000 × 5ms = 5010ms ≈ 5秒

性能提升：3倍
```

### 7.2 动态缓冲区的收益

```
场景：接收 10KB 的 RPC 响应

旧实现（1024字节缓冲区）：
  - 需要分 10 次接收
  - 每次需要唤醒协程
  - 总唤醒次数：~10 次

新实现（动态缓冲区）：
  - 一次性分配 10KB
  - 循环读取直到完整
  - 总唤醒次数：取决于网络分片，通常 1-3 次

减少协程切换开销
```

### 7.3 心跳的开销

```
假设：
- 心跳间隔：10秒
- 心跳包大小：0字节（仅探测）
- 1000 个连接

每秒心跳次数：1000 / 10 = 100 次/秒
每次心跳开销：~0.1ms（极小）
总开销：100 × 0.1ms = 10ms/秒

开销占比：0.01%（几乎可以忽略）
```

## 八、最佳实践

### 8.1 使用 RAII 管理连接

```cpp
// ✅ 推荐：使用 RAII
{
    ConnectionGuard guard(ip, port);
    auto channel = guard.get();
    // 使用 channel...
}  // 自动归还

// ❌ 不推荐：手动管理
auto channel = pool.GetConnection(ip, port);
// ... 使用 ...
pool.ReturnConnection(channel, ip, port);  // 可能忘记调用
```

### 8.2 检查连接健康状态

```cpp
auto channel = pool.GetConnection(ip, port);

// ✅ 推荐：检查后再使用
if (channel && channel->IsHealthy()) {
    // 使用连接
} else {
    // 处理错误
}

// ❌ 不推荐：直接使用
channel->CallMethod(...);  // 如果连接已断开，会失败
```

### 8.3 在 IOManager 中使用

```cpp
// ✅ 推荐：在协程环境中使用
monsoon::IOManager iom(4);
iom.scheduler([]() {
    auto channel = pool.GetConnection(...);
    // Hook 自动启用，send/recv 异步化
    // 心跳机制自动工作
});

// ⚠️ 可用但不推荐：在普通线程中使用
void normal_thread() {
    auto channel = pool.GetConnection(...);
    // 仍然能用，但：
    // 1. send/recv 是阻塞的
    // 2. 心跳机制不工作（需要 IOManager）
}
```

### 8.4 合理设置超时

```cpp
// ✅ 推荐：根据实际情况设置
// 快速响应的服务
timeout.tv_sec = 3;  

// 慢查询服务
timeout.tv_sec = 30;

// ❌ 不推荐：使用过短的超时
timeout.tv_sec = 1;  // 可能导致正常请求超时
```

## 九、故障排查

### 9.1 连接池相关

**问题**：连接池大小一直增长，不回收

**原因**：
- 没有调用 `ReturnConnection()`
- 使用了不健康的连接（自动丢弃）

**解决**：
```cpp
// 查看统计信息
std::cout << pool.GetStats() << std::endl;

// 检查是否归还连接
pool.ReturnConnection(channel, ip, port);  // 确保调用

// 使用 RAII 自动管理
```

### 9.2 状态机相关

**问题**：连接一直处于 PROBING 状态

**原因**：
- 网络不稳定，时好时坏
- 心跳探测失败但未达到阈值

**解决**：
```cpp
// 调整失败阈值
MAX_FAILURE_COUNT = 2;  // 更快进入 DISCONNECTED

// 缩短探测间隔
PROBE_INTERVAL_MS = 3000;  // 更快恢复
```

### 9.3 心跳相关

**问题**：心跳没有工作

**原因**：
- 不在 IOManager 环境中
- 定时器被取消

**检查**：
```cpp
// 检查是否在 IOManager 环境
auto iom = monsoon::IOManager::GetThis();
if (!iom) {
    std::cerr << "Not in IOManager context!" << std::endl;
}

// 检查连接状态
std::cout << "State: " << static_cast<int>(channel->GetState()) << std::endl;
```

## 十、总结

### 10.1 核心改进

1. **ConnectionPool**：高效管理连接，支持复用
2. **状态机**：精确跟踪连接健康状态
3. **心跳机制**：主动检测连接，自动恢复
4. **动态缓冲区**：正确处理任意大小的响应

### 10.2 性能提升

- ✅ **3倍** 性能提升（连接复用）
- ✅ **协程切换减少** 50%+（动态缓冲区）
- ✅ **故障恢复时间** < 15秒（探测机制）
- ✅ **资源利用率提升** 显著

### 10.3 可靠性提升

- ✅ 自动检测和丢弃不健康的连接
- ✅ 网络故障自动恢复
- ✅ 防止连接泄漏
- ✅ 准确的超时控制

---

完整示例代码：`example/connection_pool_example.cpp`


