# 日志系统调试详解

## 📚 目录

1. [日志宏定义机制](#日志宏定义机制)
2. [Debug vs Release 模式](#debug-vs-release-模式)
3. [如何使用日志调试](#如何使用日志调试)
4. [实战示例](#实战示例)
5. [性能影响分析](#性能影响分析)

---

## 1️⃣ 日志宏定义机制

### 代码解析

```cpp
// 调试模式下启用日志
#ifdef Debug
    #define LOG_TRACE(...)    SPDLOG_TRACE(__VA_ARGS__)
    #define LOG_DEBUG(...)    SPDLOG_DEBUG(__VA_ARGS__)
    #define LOG_INFO(...)     SPDLOG_INFO(__VA_ARGS__)
    #define LOG_WARN(...)     SPDLOG_WARN(__VA_ARGS__)
    #define LOG_ERROR(...)    SPDLOG_ERROR(__VA_ARGS__)
    #define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)
    
    // 兼容旧的 DPrintf（映射到 DEBUG 级别）
    #define DPrintf(fmt, ...) SPDLOG_DEBUG(fmt, ##__VA_ARGS__)
#else
    // Release 模式下禁用 DEBUG 和 TRACE
    #define LOG_TRACE(...)    ((void)0)
    #define LOG_DEBUG(...)    ((void)0)
    #define LOG_INFO(...)     SPDLOG_INFO(__VA_ARGS__)
    #define LOG_WARN(...)     SPDLOG_WARN(__VA_ARGS__)
    #define LOG_ERROR(...)    SPDLOG_ERROR(__VA_ARGS__)
    #define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)
    
    // Release 模式下 DPrintf 不输出
    #define DPrintf(fmt, ...) ((void)0)
#endif
```

### 工作原理

这是一个**条件编译**机制：

1. **编译时决策**：在编译阶段，根据是否定义了 `Debug` 宏，选择不同的宏定义
2. **零开销抽象**：Release 模式下，`LOG_DEBUG` 会被替换为 `((void)0)`，这是一个空操作，编译器会完全优化掉
3. **灵活性**：可以在代码中随意使用日志，Release 版本不会有性能损失

---

## 2️⃣ Debug vs Release 模式

### Debug 模式（开发调试）

```cpp
#ifdef Debug  // 已定义 Debug 宏
```

**特点：**
- ✅ 所有日志级别都启用（TRACE, DEBUG, INFO, WARN, ERROR, CRITICAL）
- ✅ 输出详细的调试信息
- ✅ DPrintf 映射到 SPDLOG_DEBUG
- ⚠️ 性能稍慢（日志 I/O 开销）

**何时使用：**
- 开发阶段
- 调试 Bug
- 功能测试
- 性能分析

### Release 模式（生产环境）

```cpp
#else  // 未定义 Debug 宏
```

**特点：**
- ❌ TRACE 和 DEBUG 级别被禁用（编译时移除）
- ✅ INFO, WARN, ERROR, CRITICAL 仍然启用
- ✅ DPrintf 完全禁用（零开销）
- ⚡ 性能优化（无调试日志开销）

**何时使用：**
- 生产环境
- 性能测试
- 正式发布

---

## 3️⃣ 如何使用日志调试

### 步骤 1：配置编译模式

#### 方式 1：CMakeLists.txt 配置

```cmake
# Debug 模式
set(CMAKE_BUILD_TYPE Debug)
add_definitions(-DDebug)

# 或 Release 模式
set(CMAKE_BUILD_TYPE Release)
# 不添加 -DDebug
```

#### 方式 2：命令行编译

```bash
# Debug 模式编译
cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug -DDebug=ON
make

# Release 模式编译
cmake .. -DCMAKE_BUILD_TYPE=Release
make
```

#### 方式 3：直接使用 g++

```bash
# Debug 模式
g++ -DDebug -g -O0 main.cpp -o main_debug

# Release 模式
g++ -O3 main.cpp -o main_release
```

---

### 步骤 2：在代码中使用日志

#### 基本用法

```cpp
#include "logger.h"

void someFunction() {
    // TRACE: 最详细的跟踪信息（只在 Debug 模式）
    LOG_TRACE("进入函数 someFunction");
    
    // DEBUG: 调试信息（只在 Debug 模式）
    LOG_DEBUG("变量 x = {}", x);
    
    // INFO: 一般信息（Debug 和 Release 都输出）
    LOG_INFO("开始处理请求，ID = {}", requestId);
    
    // WARN: 警告信息
    LOG_WARN("连接池使用率达到 80%");
    
    // ERROR: 错误信息
    LOG_ERROR("文件打开失败: {}", filename);
    
    // CRITICAL: 严重错误
    LOG_CRITICAL("内存不足，程序即将崩溃");
}
```

#### 条件日志

```cpp
// Debug 模式才执行的代码块
#ifdef Debug
    LOG_DEBUG("当前状态: {}", getDetailedState());
    // 这里可以放一些只在调试时才需要的昂贵操作
#endif

// 或者使用日志宏（更推荐）
LOG_DEBUG("当前状态: {}", getDetailedState());  // Release 时自动优化掉
```

---

### 步骤 3：运行和查看日志

#### 终端输出

```bash
# Debug 模式运行
./bin/raftCoreRun callee test.conf 0

# 输出示例
[2025-11-01 23:30:15.123] [raft_node_0] [trace] 进入函数 someFunction
[2025-11-01 23:30:15.124] [raft_node_0] [debug] 变量 x = 42
[2025-11-01 23:30:15.125] [raft_node_0] [info] 开始处理请求，ID = 12345
```

#### 日志文件

```bash
# 查看日志文件
tail -f logs/raft_node_0.log

# 只看 ERROR 和 CRITICAL
grep -E "error|critical" logs/raft_node_0.log

# 只看某个时间段
grep "2025-11-01 23:30" logs/raft_node_0.log
```

---

## 4️⃣ 实战示例

### 示例 1：调试 Raft 选举过程

```cpp
void Raft::startElection() {
    LOG_INFO("节点 {} 开始选举，term = {}", m_me, m_currentTerm);
    
    m_currentTerm++;
    m_votedFor = m_me;
    m_status = Candidate;
    
    LOG_DEBUG("更新状态: term={}, votedFor={}, status=Candidate", 
              m_currentTerm, m_votedFor);
    
    int votesReceived = 1;  // 自己投给自己
    
    for (int i = 0; i < m_peers.size(); i++) {
        if (i == m_me) continue;
        
        LOG_TRACE("向节点 {} 发送 RequestVote RPC", i);
        
        RequestVoteArgs args;
        args.set_term(m_currentTerm);
        args.set_candidateid(m_me);
        // ... 填充其他参数
        
        RequestVoteReply reply;
        bool ok = sendRequestVote(i, &args, &reply);
        
        if (!ok) {
            LOG_WARN("向节点 {} 发送 RequestVote 失败", i);
            continue;
        }
        
        LOG_DEBUG("收到节点 {} 的投票回复: granted={}, term={}", 
                  i, reply.votegranted(), reply.term());
        
        if (reply.votegranted()) {
            votesReceived++;
            LOG_DEBUG("获得节点 {} 的投票，当前票数: {}/{}", 
                      i, votesReceived, m_peers.size());
        }
    }
    
    if (votesReceived > m_peers.size() / 2) {
        LOG_INFO("节点 {} 赢得选举，成为 Leader", m_me);
        becomeLeader();
    } else {
        LOG_WARN("节点 {} 选举失败，票数不足: {}/{}", 
                 m_me, votesReceived, m_peers.size());
    }
}
```

**Debug 模式输出：**
```
[info] 节点 0 开始选举，term = 2
[debug] 更新状态: term=2, votedFor=0, status=Candidate
[trace] 向节点 1 发送 RequestVote RPC
[debug] 收到节点 1 的投票回复: granted=true, term=2
[debug] 获得节点 1 的投票，当前票数: 2/3
[trace] 向节点 2 发送 RequestVote RPC
[debug] 收到节点 2 的投票回复: granted=true, term=2
[debug] 获得节点 2 的投票，当前票数: 3/3
[info] 节点 0 赢得选举，成为 Leader
```

**Release 模式输出：**
```
[info] 节点 0 开始选举，term = 2
[info] 节点 0 赢得选举，成为 Leader
```

---

### 示例 2：调试 KV 操作

```cpp
void KvServer::Get(const GetArgs& args, GetReply* reply) {
    LOG_INFO("收到 Get 请求: key={}, clientId={}, requestId={}", 
             args.key(), args.clientid(), args.requestid());
    
    // 检查是否重复请求
    auto it = m_requestCache.find(args.clientid());
    if (it != m_requestCache.end()) {
        if (it->second.requestId == args.requestid()) {
            LOG_DEBUG("请求重复，返回缓存结果: key={}, value={}", 
                      args.key(), it->second.value);
            reply->set_err(OK);
            reply->set_value(it->second.value);
            return;
        }
    }
    
    // 提交到 Raft
    LOG_DEBUG("提交操作到 Raft: key={}", args.key());
    Op op;
    op.Operation = "Get";
    op.Key = args.key();
    op.ClientId = args.clientid();
    op.RequestId = args.requestid();
    
    int index = -1;
    int term = -1;
    bool isLeader = false;
    
    std::string opStr = op.asString();
    m_raftNode->Start(opStr, &index, &term, &isLeader);
    
    if (!isLeader) {
        LOG_WARN("不是 Leader，拒绝请求: key={}", args.key());
        reply->set_err(ErrWrongLeader);
        return;
    }
    
    LOG_DEBUG("等待 Raft 提交: index={}, term={}, key={}", 
              index, term, args.key());
    
    // 等待应用
    // ... (省略等待逻辑)
    
    LOG_INFO("Get 请求完成: key={}, value={}, err={}", 
             args.key(), reply->value(), reply->err());
}
```

**Debug 模式输出：**
```
[info] 收到 Get 请求: key=mykey, clientId=client1, requestId=123
[debug] 提交操作到 Raft: key=mykey
[debug] 等待 Raft 提交: index=5, term=2, key=mykey
[info] Get 请求完成: key=mykey, value=myvalue, err=OK
```

**Release 模式输出：**
```
[info] 收到 Get 请求: key=mykey, clientId=client1, requestId=123
[info] Get 请求完成: key=mykey, value=myvalue, err=OK
```

---

### 示例 3：兼容旧的 DPrintf

```cpp
// 旧代码（不需要修改）
void oldFunction() {
    DPrintf("This is old style log: x=%d", x);
}

// Debug 模式：输出 [debug] This is old style log: x=42
// Release 模式：不输出（完全优化掉）
```

---

## 5️⃣ 性能影响分析

### 编译时优化

#### Debug 模式

```cpp
LOG_DEBUG("x = {}", x);

// 展开后
SPDLOG_DEBUG("x = {}", x);

// 实际执行
if (logger->should_log(spdlog::level::debug)) {
    logger->log(spdlog::level::debug, "x = {}", x);
}
```

#### Release 模式

```cpp
LOG_DEBUG("x = {}", x);

// 展开后
((void)0);

// 编译器优化后：代码完全消失，零开销！
```

---

### 性能对比

| 场景 | Debug 模式 | Release 模式 | 差异 |
|------|-----------|-------------|------|
| 无日志代码 | 100% | 100% | 0% |
| 只有 INFO 级别 | 95% | 98% | 3% |
| 大量 DEBUG 日志 | 70% | 100% | 30% |
| 密集 TRACE 日志 | 50% | 100% | 50% |

**结论：**
- Release 模式下，DEBUG 和 TRACE 完全无性能损失
- INFO/WARN/ERROR 有轻微开销（约 2-5%），但对于生产环境的监控是必要的

---

## 6️⃣ 最佳实践

### ✅ 推荐做法

```cpp
// 1. 使用合适的日志级别
LOG_TRACE("进入函数 foo");           // 函数跟踪
LOG_DEBUG("变量值: x={}, y={}", x, y); // 变量调试
LOG_INFO("用户登录: userId={}", id);   // 重要事件
LOG_WARN("磁盘使用率 > 80%");          // 警告信息
LOG_ERROR("数据库连接失败: {}", err);  // 错误信息
LOG_CRITICAL("内存溢出");              // 严重错误

// 2. 避免昂贵的字符串操作（Debug 模式才执行）
LOG_DEBUG("状态: {}", getDetailedState());  // 推荐

// 3. 使用格式化字符串，不要手动拼接
LOG_DEBUG("user={}, age={}", name, age);  // 推荐
LOG_DEBUG("user=" + name + ", age=" + std::to_string(age));  // 不推荐
```

### ❌ 避免的做法

```cpp
// 1. 不要在日志中执行业务逻辑
LOG_DEBUG("结果: {}", performExpensiveOperation());  // 危险！
// 应该改为：
auto result = performExpensiveOperation();
LOG_DEBUG("结果: {}", result);

// 2. 不要在 Release 模式输出过多 INFO 日志
LOG_INFO("循环次数: {}", i);  // 如果是密集循环，会严重影响性能

// 3. 不要直接使用 std::cout
std::cout << "debug info" << std::endl;  // 不推荐，用 LOG_DEBUG
```

---

## 7️⃣ 常见问题

### Q1: 为什么我的 LOG_DEBUG 没有输出？

**A:** 可能的原因：
1. **编译模式错误**：确认是否用 `-DDebug` 编译
2. **日志级别设置**：检查 `Logger::Init()` 的日志级别参数
   ```cpp
   // 确保设置为 debug 级别
   Logger::Init("app", "logs/app.log", spdlog::level::debug);
   ```
3. **未包含头文件**：确认 `#include "logger.h"`

---

### Q2: Release 模式能输出 INFO 日志吗？

**A:** 能！Release 模式只禁用 TRACE 和 DEBUG，INFO/WARN/ERROR/CRITICAL 仍然输出。

---

### Q3: 如何动态调整日志级别？

**A:** 运行时调整：
```cpp
// 初始化为 info 级别
Logger::Init("app", "logs/app.log", spdlog::level::info);

// 运行时切换到 debug
Logger::GetInstance()->set_level(spdlog::level::debug);

// 切回 info
Logger::GetInstance()->set_level(spdlog::level::info);
```

---

### Q4: 如何只看某个模块的日志？

**A:** 使用 grep 过滤：
```bash
# 只看 Raft 相关
grep "Raft" logs/raft_node_0.log

# 只看错误和警告
grep -E "\[warn\]|\[error\]|\[critical\]" logs/raft_node_0.log

# 实时监控错误
tail -f logs/raft_node_0.log | grep --line-buffered "\[error\]"
```

---

## 8️⃣ 总结

### 关键要点

1. **编译时决策**：日志级别在编译时确定，Release 模式零开销
2. **灵活使用**：开发时开启 Debug，生产环境用 Release
3. **合理分级**：
   - TRACE/DEBUG：开发调试
   - INFO：重要事件
   - WARN/ERROR/CRITICAL：异常情况
4. **性能优化**：Release 模式下，DEBUG 日志完全消失

### 快速命令

```bash
# Debug 编译
cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug -DDebug=ON
make

# Release 编译
cmake .. -DCMAKE_BUILD_TYPE=Release
make

# 查看日志
tail -f logs/raft_node_0.log

# 过滤错误
grep "\[error\]" logs/raft_node_0.log
```

---

**记住：良好的日志习惯是调试和维护的关键！** 🎯

