# KV存储RAFT项目 - 调试指南

## 📋 为什么 GDB 调试困难？

### 🤔 协程环境下的调试挑战

你说得对！这个项目使用协程后，传统的 GDB 调试变得非常困难：

#### 1. **协程栈切换问题**
```
传统线程模型:
Thread 1 → Function A → Function B → Function C
         ↑ GDB 可以轻松查看完整调用栈

协程模型:
Thread 1 → Scheduler → Fiber 1 (A → B) ⇄ Fiber 2 (X → Y) ⇄ Fiber 3 (M → N)
                          ↑           ↑           ↑
                          栈1         栈2         栈3
         ↑ GDB 只能看到当前 Fiber 的栈，看不到其他 Fiber
```

**问题**：
- GDB 的 `backtrace` 只显示当前协程的栈
- 其他协程的栈信息丢失
- 协程切换时，调用栈会"跳跃"

#### 2. **Hook 机制干扰**
```cpp
// 你的代码
send(fd, data, len, 0);

// 实际执行路径（被Hook后）
→ hook.cpp::send()
  → 检查是否在协程环境
  → 调用 IOManager
  → 注册 epoll 事件
  → Fiber::yield()  // 协程切换！
  → ... 其他协程运行 ...
  → 事件触发
  → Fiber::resume()
  → 返回 send 结果
```

**问题**：
- 单步调试时，会跳进 Hook 函数的复杂逻辑
- 很难追踪实际的业务逻辑
- 断点可能在协程切换后失效

#### 3. **多协程并发执行**
```
Thread 1 上运行：
  [时刻1] Fiber A 执行到第10行 → yield
  [时刻2] Fiber B 执行到第20行 → yield  
  [时刻3] Fiber A 继续第11行 → yield
  [时刻4] Fiber C 执行到第30行
```

**问题**：
- 你在 Fiber A 设置断点，但可能先断在 Fiber B
- 很难只调试某一个协程
- 时序问题难以重现

#### 4. **状态不可见**
```cpp
// GDB 中查看
(gdb) print fiber_status
// ❌ 看不到其他协程的状态

// 想要的信息
Fiber 1: RUNNING (在第10行)
Fiber 2: WAITING (等待 I/O)
Fiber 3: READY (待调度)
Fiber 4: SUSPENDED (被挂起)
```

---

## ✅ 当前项目的调试方法

### 1. DPrintf - 主要调试工具

#### 📍 位置
```cpp
// src/common/include/config.h
const bool Debug = true;  // 全局开关

// src/common/util.cpp (55-68行)
void DPrintf(const char *format, ...) {
  if (Debug) {
    time_t now = time(nullptr);
    tm *nowtm = localtime(&now);
    va_list args;
    va_start(args, format);
    std::printf("[%d-%d-%d-%d-%d-%d] ", 
                nowtm->tm_year + 1900, nowtm->tm_mon + 1, 
                nowtm->tm_mday, nowtm->tm_hour,
                nowtm->tm_min, nowtm->tm_sec);
    std::vprintf(format, args);
    std::printf("\n");
    va_end(args);
  }
}
```

#### 💡 使用示例
```cpp
// raft.cpp 中的使用
DPrintf("[func-AppendEntries-rf{%d}] 拒绝了节点{%d}，prevLogIndex=%d", 
        m_me, args->leaderid(), args->prevlogindex());

// 输出格式：
// [2025-10-28-16-30-45] [func-AppendEntries-rf{0}] 拒绝了节点{1}，prevLogIndex=5
```

#### 📊 统计信息
```bash
# 项目中 DPrintf 使用统计
$ grep -r "DPrintf" src/ | wc -l
86  # 共86处使用
```

#### ⚠️ 当前问题

1. **性能影响**：
   - 每次 DPrintf 都要格式化时间、调用 printf
   - `printf` 内部有锁，多线程竞争
   - 在 `提升.md` 中已识别为 P1 问题

2. **不够灵活**：
   - 只有全局开关 `Debug`
   - 无法按模块、按级别控制
   - 日志混在一起，难以过滤

3. **功能简陋**：
   - 没有日志级别（INFO、WARN、ERROR）
   - 没有日志文件，只输出到 stdout
   - 没有日志轮转

---

## 🔧 推荐的调试方案

### 方案1: 改进 DPrintf（推荐，快速）

#### 实现分级日志

```cpp
// config.h
enum class LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
};

const LogLevel CurrentLogLevel = LogLevel::DEBUG;

// util.h
#define LOG_DEBUG(fmt, ...) LogPrint(LogLevel::DEBUG, "[DEBUG]", __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...)  LogPrint(LogLevel::INFO,  "[INFO]",  __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_WARN(fmt, ...)  LogPrint(LogLevel::WARN,  "[WARN]",  __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) LogPrint(LogLevel::ERROR, "[ERROR]", __FILE__, __LINE__, fmt, ##__VA_ARGS__)

// util.cpp
void LogPrint(LogLevel level, const char* levelStr, 
              const char* file, int line, 
              const char* format, ...) {
    if (level < CurrentLogLevel) return;  // 过滤
    
    // 获取时间
    auto now = std::chrono::system_clock::now();
    auto time_t_now = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                  now.time_since_epoch()) % 1000;
    
    // 格式化输出
    char timeBuffer[64];
    strftime(timeBuffer, sizeof(timeBuffer), "%Y-%m-%d %H:%M:%S", 
             localtime(&time_t_now));
    
    // 添加协程ID和线程ID
    std::ostringstream oss;
    oss << "[" << timeBuffer << "." << std::setfill('0') << std::setw(3) << ms.count() << "]"
        << " " << levelStr
        << " [tid:" << std::this_thread::get_id() << "]"
        << " [" << file << ":" << line << "] ";
    
    std::cout << oss.str();
    
    // 打印实际内容
    va_list args;
    va_start(args, format);
    std::vprintf(format, args);
    va_end(args);
    std::cout << std::endl;
}
```

#### 使用示例

```cpp
// 旧代码：
DPrintf("[func-AppendEntries-rf{%d}] 拒绝了节点{%d}", m_me, leader_id);

// 新代码：
LOG_INFO("AppendEntries: Node[%d] rejected request from Leader[%d], term=%d", 
         m_me, leader_id, term);
LOG_DEBUG("AppendEntries: prevLogIndex=%d, entriesSize=%d", 
          prevLogIndex, entries.size());
LOG_ERROR("AppendEntries: Invalid log term! expected=%d, got=%d", 
          expected, actual);
```

#### 输出示例

```
[2025-10-28 16:30:45.123] [INFO]  [tid:140234567] [raft.cpp:123] AppendEntries: Node[0] rejected request from Leader[1], term=5
[2025-10-28 16:30:45.124] [DEBUG] [tid:140234567] [raft.cpp:124] AppendEntries: prevLogIndex=10, entriesSize=3
[2025-10-28 16:30:45.125] [ERROR] [tid:140234567] [raft.cpp:125] AppendEntries: Invalid log term! expected=5, got=3
```

---

### 方案2: 使用 spdlog（推荐，生产级）

#### 安装

```bash
# Ubuntu/Debian
sudo apt install libspdlog-dev

# 或从源码安装
git clone https://github.com/gabime/spdlog.git
cd spdlog && mkdir build && cd build
cmake .. && make -j && sudo make install
```

#### 集成到项目

```cpp
// logger.h
#pragma once
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <memory>

class Logger {
public:
    static void Init() {
        // 控制台日志（彩色）
        auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
        console_sink->set_level(spdlog::level::debug);
        
        // 文件日志（自动轮转）
        auto file_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            "logs/raft.log", 1024 * 1024 * 10, 3);  // 10MB, 保留3个文件
        file_sink->set_level(spdlog::level::trace);
        
        // 组合
        std::vector<spdlog::sink_ptr> sinks{console_sink, file_sink};
        auto logger = std::make_shared<spdlog::logger>("raft", 
                                                        sinks.begin(), sinks.end());
        logger->set_level(spdlog::level::debug);
        logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [tid:%t] [%s:%#] %v");
        
        spdlog::set_default_logger(logger);
    }
    
    static std::shared_ptr<spdlog::logger> Get() {
        return spdlog::default_logger();
    }
};

// 宏定义
#define LOG_TRACE(...)    SPDLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...)    SPDLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...)     SPDLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...)     SPDLOG_WARN(__VA_ARGS__)
#define LOG_ERROR(...)    SPDLOG_ERROR(__VA_ARGS__)
#define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)
```

#### 使用示例

```cpp
// main.cpp
int main() {
    Logger::Init();  // 初始化日志系统
    
    // 使用
    LOG_INFO("RAFT node {} starting...", node_id);
    LOG_DEBUG("Config loaded: heartbeat={}ms, election={}ms", 
              heartbeat_timeout, election_timeout);
    LOG_ERROR("Failed to connect to node {}: {}", peer_id, error_msg);
}

// raft.cpp
void Raft::AppendEntries1(...) {
    LOG_INFO("Node[{}] received AppendEntries from Leader[{}], term={}", 
             m_me, args->leaderid(), args->term());
    
    if (args->term() < m_currentTerm) {
        LOG_WARN("Node[{}] rejected AE: stale term (leader={}, mine={})", 
                 m_me, args->term(), m_currentTerm);
        return;
    }
    
    LOG_DEBUG("Node[{}] processing {} log entries", m_me, args->entries_size());
}
```

#### 优势

✅ **高性能**：
- 异步日志（不阻塞主逻辑）
- 零拷贝
- 无锁设计

✅ **功能丰富**：
- 日志级别控制
- 彩色输出
- 文件轮转
- 支持多种 sink（文件、控制台、syslog等）

✅ **线程安全**：
- 内置线程安全
- 适合多线程/协程环境

---

### 方案3: 协程感知调试工具（高级）

#### 实现协程调试器

```cpp
// fiber_debugger.h
#pragma once
#include <unordered_map>
#include <mutex>
#include <sstream>

class FiberDebugger {
public:
    static FiberDebugger& Instance() {
        static FiberDebugger instance;
        return instance;
    }
    
    // 注册协程
    void RegisterFiber(uint64_t fiber_id, const std::string& name) {
        std::lock_guard<std::mutex> lock(mutex_);
        fiber_names_[fiber_id] = name;
        fiber_states_[fiber_id] = "READY";
    }
    
    // 更新协程状态
    void UpdateState(uint64_t fiber_id, const std::string& state) {
        std::lock_guard<std::mutex> lock(mutex_);
        fiber_states_[fiber_id] = state;
    }
    
    // 记录协程切换
    void LogSwitch(uint64_t from_fiber, uint64_t to_fiber) {
        LOG_TRACE("Fiber switch: {} -> {}", 
                  GetFiberName(from_fiber), GetFiberName(to_fiber));
    }
    
    // 获取所有协程状态
    std::string DumpAllFibers() {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ostringstream oss;
        oss << "\n=== Fiber States ===\n";
        for (const auto& [id, name] : fiber_names_) {
            oss << "Fiber[" << id << "] '" << name << "': " 
                << fiber_states_[id] << "\n";
        }
        return oss.str();
    }
    
private:
    std::mutex mutex_;
    std::unordered_map<uint64_t, std::string> fiber_names_;
    std::unordered_map<uint64_t, std::string> fiber_states_;
    
    std::string GetFiberName(uint64_t id) {
        auto it = fiber_names_.find(id);
        return it != fiber_names_.end() ? it->second : std::to_string(id);
    }
};

// 便捷宏
#define FIBER_DEBUG_REGISTER(name) \
    FiberDebugger::Instance().RegisterFiber(Fiber::GetThis()->getId(), name)

#define FIBER_DEBUG_STATE(state) \
    FiberDebugger::Instance().UpdateState(Fiber::GetThis()->getId(), state)

#define FIBER_DEBUG_DUMP() \
    LOG_DEBUG("{}", FiberDebugger::Instance().DumpAllFibers())
```

#### 使用示例

```cpp
// raft.cpp
void Raft::leaderHearBeatTicker() {
    FIBER_DEBUG_REGISTER("HeartbeatTicker");
    
    while (true) {
        FIBER_DEBUG_STATE("SLEEPING");
        usleep(HeartBeatTimeout * 1000);
        
        FIBER_DEBUG_STATE("CHECKING");
        if (m_status == Leader) {
            FIBER_DEBUG_STATE("SENDING_HEARTBEAT");
            doHeartbeat();
        }
    }
}

// 输出：
// [TRACE] Fiber switch: HeartbeatTicker -> ApplierTicker
// [DEBUG] === Fiber States ===
//         Fiber[1] 'HeartbeatTicker': SLEEPING
//         Fiber[2] 'ApplierTicker': RUNNING
//         Fiber[3] 'ElectionTicker': SLEEPING
```

---

## 🛠️ 实用调试技巧

### 1. 条件日志

```cpp
// 只记录特定节点的日志
#define LOG_NODE(node_id, level, fmt, ...) \
    if (m_me == node_id) { \
        LOG_##level(fmt, ##__VA_ARGS__); \
    }

// 使用
LOG_NODE(0, INFO, "Node 0: AppendEntries received");  // 只有节点0输出
```

### 2. 性能日志

```cpp
// 记录函数执行时间
class ScopedTimer {
public:
    ScopedTimer(const std::string& name) : name_(name) {
        start_ = std::chrono::high_resolution_clock::now();
    }
    
    ~ScopedTimer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                            end - start_).count();
        LOG_DEBUG("{} took {} us", name_, duration);
    }
    
private:
    std::string name_;
    std::chrono::time_point<std::chrono::high_resolution_clock> start_;
};

// 使用
void Raft::AppendEntries1(...) {
    ScopedTimer timer("AppendEntries1");
    // ... 函数逻辑
}  // 自动输出耗时
```

### 3. 状态快照

```cpp
// 定期输出系统状态
void Raft::DumpState() {
    LOG_INFO("=== RAFT State Dump ===");
    LOG_INFO("Node: {}, Term: {}, Status: {}", 
             m_me, m_currentTerm, StatusToString(m_status));
    LOG_INFO("LastLogIndex: {}, CommitIndex: {}, LastApplied: {}", 
             getLastLogIndex(), m_commitIndex, m_lastApplied);
    LOG_INFO("Logs: {} entries", m_logs.size());
    
    if (m_status == Leader) {
        LOG_INFO("NextIndex: [{}]", FormatVector(m_nextIndex));
        LOG_INFO("MatchIndex: [{}]", FormatVector(m_matchIndex));
    }
}

// 定时调用
std::thread([this]() {
    while (true) {
        sleep(10);
        DumpState();
    }
}).detach();
```

### 4. 事件追踪

```cpp
// 追踪关键事件
enum class Event {
    ELECTION_START,
    ELECTION_TIMEOUT,
    BECOME_LEADER,
    BECOME_FOLLOWER,
    RECEIVE_AE,
    SEND_AE,
    LOG_COMMITTED
};

void LogEvent(Event event, const std::string& details = "") {
    static const char* EventNames[] = {
        "ELECTION_START", "ELECTION_TIMEOUT", "BECOME_LEADER",
        "BECOME_FOLLOWER", "RECEIVE_AE", "SEND_AE", "LOG_COMMITTED"
    };
    
    LOG_INFO("[EVENT] Node[{}] {} {}", m_me, EventNames[(int)event], details);
}

// 使用
void Raft::doElection() {
    LogEvent(Event::ELECTION_START, format("term={}", m_currentTerm + 1));
    // ...
}
```

---

## 📊 对比：GDB vs 日志调试

| 特性 | GDB | 日志调试 |
|------|-----|---------|
| **适用场景** | 单线程、简单逻辑 | 多线程、协程、分布式 |
| **实时性** | 实时查看变量 | 事后分析 |
| **影响性能** | 停止程序执行 | 异步日志影响小 |
| **并发调试** | 困难 ⚠️ | 容易 ✅ |
| **协程调试** | 非常困难 ❌ | 适合 ✅ |
| **分布式调试** | 不支持 ❌ | 支持（日志聚合）✅ |
| **历史回溯** | 不支持 ❌ | 支持（日志文件）✅ |
| **学习成本** | 高 | 低 |

---

## 🚀 推荐调试流程

### 开发阶段

```bash
# 1. 启用详细日志
# 修改 config.h
const LogLevel CurrentLogLevel = LogLevel::DEBUG;

# 2. 运行测试
./bin/raftCoreRun -i 0 -f test.conf 2>&1 | tee node0.log

# 3. 分析日志
grep "ERROR" node0.log
grep "Node\[0\]" node0.log | less
```

### 问题定位

```bash
# 场景1: 查找特定节点的选举过程
grep "ELECTION" node0.log

# 场景2: 追踪特定 term 的所有操作
grep "term=5" node0.log

# 场景3: 查看日志复制过程
grep "AppendEntries" node*.log | sort

# 场景4: 分析性能问题
grep "took.*ms" node0.log | awk '{print $NF}' | sort -n
```

### 生产环境

```bash
# 1. 只记录 WARN 和 ERROR
const LogLevel CurrentLogLevel = LogLevel::WARN;

# 2. 日志轮转
# 使用 spdlog 的自动轮转
# 或使用 logrotate

# 3. 日志聚合
# 使用 ELK、Loki 等工具
```

---

## 💡 最佳实践

### 1. 日志格式规范

```cpp
// ✅ 好的日志
LOG_INFO("Node[{}] AppendEntries: from={}, term={}, entries={}", 
         m_me, leader_id, term, count);

// ❌ 不好的日志
LOG_INFO("AE");  // 信息不足
LOG_INFO("收到心跳");  // 缺少关键信息
```

### 2. 关键路径必须记录

```cpp
// Leader选举
LOG_INFO("Node[{}] starting election, term={}", m_me, new_term);

// 日志复制
LOG_INFO("Node[{}] sending AE to Node[{}]: prevLog=({},{}), entries={}", 
         m_me, peer, prevLogIndex, prevLogTerm, entries.size());

// 状态变更
LOG_INFO("Node[{}] state change: {} -> {}", m_me, old_state, new_state);
```

### 3. 错误必须记录

```cpp
// ✅ 记录错误上下文
LOG_ERROR("Node[{}] failed to send AE to Node[{}]: {}, retrying...", 
          m_me, peer, error_msg);

// ❌ 只记录错误
LOG_ERROR("Send failed");
```

---

## 🎯 立即行动

### 快速改进当前的 DPrintf

```cpp
// 1. 添加到 util.h
#define LOG_DEBUG(fmt, ...) \
    if (Debug) { \
        printf("[DEBUG][%s:%d] ", __FILE__, __LINE__); \
        printf(fmt, ##__VA_ARGS__); \
        printf("\n"); \
    }

// 2. 替换现有的 DPrintf
// 旧: DPrintf("[func-AppendEntries] ...");
// 新: LOG_DEBUG("AppendEntries: ...");

// 3. 添加条件编译
#ifdef ENABLE_DEBUG_LOG
  #define LOG_DEBUG(fmt, ...) ...
#else
  #define LOG_DEBUG(fmt, ...) do {} while(0)
#endif
```

---

## 📚 总结

1. **为什么难用 GDB**：
   - 协程栈切换
   - Hook 机制复杂
   - 并发执行难追踪

2. **当前方案**：
   - DPrintf（86处使用）
   - 简单但有效

3. **建议改进**：
   - 短期：改进 DPrintf 添加日志级别
   - 长期：集成 spdlog
   - 高级：实现协程调试器

4. **最佳实践**：
   - 关键路径必须记录
   - 日志格式规范化
   - 分级控制输出

**对于协程化的分布式系统，日志调试比 GDB 更实用！** 📝

