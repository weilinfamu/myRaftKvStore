# KVå­˜å‚¨RAFTé¡¹ç›® - è°ƒè¯•æŒ‡å—

## ğŸ“‹ ä¸ºä»€ä¹ˆ GDB è°ƒè¯•å›°éš¾ï¼Ÿ

### ğŸ¤” åç¨‹ç¯å¢ƒä¸‹çš„è°ƒè¯•æŒ‘æˆ˜

ä½ è¯´å¾—å¯¹ï¼è¿™ä¸ªé¡¹ç›®ä½¿ç”¨åç¨‹åï¼Œä¼ ç»Ÿçš„ GDB è°ƒè¯•å˜å¾—éå¸¸å›°éš¾ï¼š

#### 1. **åç¨‹æ ˆåˆ‡æ¢é—®é¢˜**
```
ä¼ ç»Ÿçº¿ç¨‹æ¨¡å‹:
Thread 1 â†’ Function A â†’ Function B â†’ Function C
         â†‘ GDB å¯ä»¥è½»æ¾æŸ¥çœ‹å®Œæ•´è°ƒç”¨æ ˆ

åç¨‹æ¨¡å‹:
Thread 1 â†’ Scheduler â†’ Fiber 1 (A â†’ B) â‡„ Fiber 2 (X â†’ Y) â‡„ Fiber 3 (M â†’ N)
                          â†‘           â†‘           â†‘
                          æ ˆ1         æ ˆ2         æ ˆ3
         â†‘ GDB åªèƒ½çœ‹åˆ°å½“å‰ Fiber çš„æ ˆï¼Œçœ‹ä¸åˆ°å…¶ä»– Fiber
```

**é—®é¢˜**ï¼š
- GDB çš„ `backtrace` åªæ˜¾ç¤ºå½“å‰åç¨‹çš„æ ˆ
- å…¶ä»–åç¨‹çš„æ ˆä¿¡æ¯ä¸¢å¤±
- åç¨‹åˆ‡æ¢æ—¶ï¼Œè°ƒç”¨æ ˆä¼š"è·³è·ƒ"

#### 2. **Hook æœºåˆ¶å¹²æ‰°**
```cpp
// ä½ çš„ä»£ç 
send(fd, data, len, 0);

// å®é™…æ‰§è¡Œè·¯å¾„ï¼ˆè¢«Hookåï¼‰
â†’ hook.cpp::send()
  â†’ æ£€æŸ¥æ˜¯å¦åœ¨åç¨‹ç¯å¢ƒ
  â†’ è°ƒç”¨ IOManager
  â†’ æ³¨å†Œ epoll äº‹ä»¶
  â†’ Fiber::yield()  // åç¨‹åˆ‡æ¢ï¼
  â†’ ... å…¶ä»–åç¨‹è¿è¡Œ ...
  â†’ äº‹ä»¶è§¦å‘
  â†’ Fiber::resume()
  â†’ è¿”å› send ç»“æœ
```

**é—®é¢˜**ï¼š
- å•æ­¥è°ƒè¯•æ—¶ï¼Œä¼šè·³è¿› Hook å‡½æ•°çš„å¤æ‚é€»è¾‘
- å¾ˆéš¾è¿½è¸ªå®é™…çš„ä¸šåŠ¡é€»è¾‘
- æ–­ç‚¹å¯èƒ½åœ¨åç¨‹åˆ‡æ¢åå¤±æ•ˆ

#### 3. **å¤šåç¨‹å¹¶å‘æ‰§è¡Œ**
```
Thread 1 ä¸Šè¿è¡Œï¼š
  [æ—¶åˆ»1] Fiber A æ‰§è¡Œåˆ°ç¬¬10è¡Œ â†’ yield
  [æ—¶åˆ»2] Fiber B æ‰§è¡Œåˆ°ç¬¬20è¡Œ â†’ yield  
  [æ—¶åˆ»3] Fiber A ç»§ç»­ç¬¬11è¡Œ â†’ yield
  [æ—¶åˆ»4] Fiber C æ‰§è¡Œåˆ°ç¬¬30è¡Œ
```

**é—®é¢˜**ï¼š
- ä½ åœ¨ Fiber A è®¾ç½®æ–­ç‚¹ï¼Œä½†å¯èƒ½å…ˆæ–­åœ¨ Fiber B
- å¾ˆéš¾åªè°ƒè¯•æŸä¸€ä¸ªåç¨‹
- æ—¶åºé—®é¢˜éš¾ä»¥é‡ç°

#### 4. **çŠ¶æ€ä¸å¯è§**
```cpp
// GDB ä¸­æŸ¥çœ‹
(gdb) print fiber_status
// âŒ çœ‹ä¸åˆ°å…¶ä»–åç¨‹çš„çŠ¶æ€

// æƒ³è¦çš„ä¿¡æ¯
Fiber 1: RUNNING (åœ¨ç¬¬10è¡Œ)
Fiber 2: WAITING (ç­‰å¾… I/O)
Fiber 3: READY (å¾…è°ƒåº¦)
Fiber 4: SUSPENDED (è¢«æŒ‚èµ·)
```

---

## âœ… å½“å‰é¡¹ç›®çš„è°ƒè¯•æ–¹æ³•

### 1. DPrintf - ä¸»è¦è°ƒè¯•å·¥å…·

#### ğŸ“ ä½ç½®
```cpp
// src/common/include/config.h
const bool Debug = true;  // å…¨å±€å¼€å…³

// src/common/util.cpp (55-68è¡Œ)
void DPrintf(const char *format, ...) {
  if (Debug) {
    time_t now = time(nullptr);
    tm *nowtm = localtime(&now);
    va_list args;
    va_start(args, format);
    std::printf("[%d-%d-%d-%d-%d-%d] ", 
                nowtm->tm_year + 1900, nowtm->tm_mon + 1, 
                nowtm->tm_mday, nowtm->tm_hour,
                nowtm->tm_min, nowtm->tm_sec);
    std::vprintf(format, args);
    std::printf("\n");
    va_end(args);
  }
}
```

#### ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹
```cpp
// raft.cpp ä¸­çš„ä½¿ç”¨
DPrintf("[func-AppendEntries-rf{%d}] æ‹’ç»äº†èŠ‚ç‚¹{%d}ï¼ŒprevLogIndex=%d", 
        m_me, args->leaderid(), args->prevlogindex());

// è¾“å‡ºæ ¼å¼ï¼š
// [2025-10-28-16-30-45] [func-AppendEntries-rf{0}] æ‹’ç»äº†èŠ‚ç‚¹{1}ï¼ŒprevLogIndex=5
```

#### ğŸ“Š ç»Ÿè®¡ä¿¡æ¯
```bash
# é¡¹ç›®ä¸­ DPrintf ä½¿ç”¨ç»Ÿè®¡
$ grep -r "DPrintf" src/ | wc -l
86  # å…±86å¤„ä½¿ç”¨
```

#### âš ï¸ å½“å‰é—®é¢˜

1. **æ€§èƒ½å½±å“**ï¼š
   - æ¯æ¬¡ DPrintf éƒ½è¦æ ¼å¼åŒ–æ—¶é—´ã€è°ƒç”¨ printf
   - `printf` å†…éƒ¨æœ‰é”ï¼Œå¤šçº¿ç¨‹ç«äº‰
   - åœ¨ `æå‡.md` ä¸­å·²è¯†åˆ«ä¸º P1 é—®é¢˜

2. **ä¸å¤Ÿçµæ´»**ï¼š
   - åªæœ‰å…¨å±€å¼€å…³ `Debug`
   - æ— æ³•æŒ‰æ¨¡å—ã€æŒ‰çº§åˆ«æ§åˆ¶
   - æ—¥å¿—æ··åœ¨ä¸€èµ·ï¼Œéš¾ä»¥è¿‡æ»¤

3. **åŠŸèƒ½ç®€é™‹**ï¼š
   - æ²¡æœ‰æ—¥å¿—çº§åˆ«ï¼ˆINFOã€WARNã€ERRORï¼‰
   - æ²¡æœ‰æ—¥å¿—æ–‡ä»¶ï¼Œåªè¾“å‡ºåˆ° stdout
   - æ²¡æœ‰æ—¥å¿—è½®è½¬

---

## ğŸ”§ æ¨èçš„è°ƒè¯•æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: æ”¹è¿› DPrintfï¼ˆæ¨èï¼Œå¿«é€Ÿï¼‰

#### å®ç°åˆ†çº§æ—¥å¿—

```cpp
// config.h
enum class LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
};

const LogLevel CurrentLogLevel = LogLevel::DEBUG;

// util.h
#define LOG_DEBUG(fmt, ...) LogPrint(LogLevel::DEBUG, "[DEBUG]", __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...)  LogPrint(LogLevel::INFO,  "[INFO]",  __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_WARN(fmt, ...)  LogPrint(LogLevel::WARN,  "[WARN]",  __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_ERROR(fmt, ...) LogPrint(LogLevel::ERROR, "[ERROR]", __FILE__, __LINE__, fmt, ##__VA_ARGS__)

// util.cpp
void LogPrint(LogLevel level, const char* levelStr, 
              const char* file, int line, 
              const char* format, ...) {
    if (level < CurrentLogLevel) return;  // è¿‡æ»¤
    
    // è·å–æ—¶é—´
    auto now = std::chrono::system_clock::now();
    auto time_t_now = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                  now.time_since_epoch()) % 1000;
    
    // æ ¼å¼åŒ–è¾“å‡º
    char timeBuffer[64];
    strftime(timeBuffer, sizeof(timeBuffer), "%Y-%m-%d %H:%M:%S", 
             localtime(&time_t_now));
    
    // æ·»åŠ åç¨‹IDå’Œçº¿ç¨‹ID
    std::ostringstream oss;
    oss << "[" << timeBuffer << "." << std::setfill('0') << std::setw(3) << ms.count() << "]"
        << " " << levelStr
        << " [tid:" << std::this_thread::get_id() << "]"
        << " [" << file << ":" << line << "] ";
    
    std::cout << oss.str();
    
    // æ‰“å°å®é™…å†…å®¹
    va_list args;
    va_start(args, format);
    std::vprintf(format, args);
    va_end(args);
    std::cout << std::endl;
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```cpp
// æ—§ä»£ç ï¼š
DPrintf("[func-AppendEntries-rf{%d}] æ‹’ç»äº†èŠ‚ç‚¹{%d}", m_me, leader_id);

// æ–°ä»£ç ï¼š
LOG_INFO("AppendEntries: Node[%d] rejected request from Leader[%d], term=%d", 
         m_me, leader_id, term);
LOG_DEBUG("AppendEntries: prevLogIndex=%d, entriesSize=%d", 
          prevLogIndex, entries.size());
LOG_ERROR("AppendEntries: Invalid log term! expected=%d, got=%d", 
          expected, actual);
```

#### è¾“å‡ºç¤ºä¾‹

```
[2025-10-28 16:30:45.123] [INFO]  [tid:140234567] [raft.cpp:123] AppendEntries: Node[0] rejected request from Leader[1], term=5
[2025-10-28 16:30:45.124] [DEBUG] [tid:140234567] [raft.cpp:124] AppendEntries: prevLogIndex=10, entriesSize=3
[2025-10-28 16:30:45.125] [ERROR] [tid:140234567] [raft.cpp:125] AppendEntries: Invalid log term! expected=5, got=3
```

---

### æ–¹æ¡ˆ2: ä½¿ç”¨ spdlogï¼ˆæ¨èï¼Œç”Ÿäº§çº§ï¼‰

#### å®‰è£…

```bash
# Ubuntu/Debian
sudo apt install libspdlog-dev

# æˆ–ä»æºç å®‰è£…
git clone https://github.com/gabime/spdlog.git
cd spdlog && mkdir build && cd build
cmake .. && make -j && sudo make install
```

#### é›†æˆåˆ°é¡¹ç›®

```cpp
// logger.h
#pragma once
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <memory>

class Logger {
public:
    static void Init() {
        // æ§åˆ¶å°æ—¥å¿—ï¼ˆå½©è‰²ï¼‰
        auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
        console_sink->set_level(spdlog::level::debug);
        
        // æ–‡ä»¶æ—¥å¿—ï¼ˆè‡ªåŠ¨è½®è½¬ï¼‰
        auto file_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            "logs/raft.log", 1024 * 1024 * 10, 3);  // 10MB, ä¿ç•™3ä¸ªæ–‡ä»¶
        file_sink->set_level(spdlog::level::trace);
        
        // ç»„åˆ
        std::vector<spdlog::sink_ptr> sinks{console_sink, file_sink};
        auto logger = std::make_shared<spdlog::logger>("raft", 
                                                        sinks.begin(), sinks.end());
        logger->set_level(spdlog::level::debug);
        logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [tid:%t] [%s:%#] %v");
        
        spdlog::set_default_logger(logger);
    }
    
    static std::shared_ptr<spdlog::logger> Get() {
        return spdlog::default_logger();
    }
};

// å®å®šä¹‰
#define LOG_TRACE(...)    SPDLOG_TRACE(__VA_ARGS__)
#define LOG_DEBUG(...)    SPDLOG_DEBUG(__VA_ARGS__)
#define LOG_INFO(...)     SPDLOG_INFO(__VA_ARGS__)
#define LOG_WARN(...)     SPDLOG_WARN(__VA_ARGS__)
#define LOG_ERROR(...)    SPDLOG_ERROR(__VA_ARGS__)
#define LOG_CRITICAL(...) SPDLOG_CRITICAL(__VA_ARGS__)
```

#### ä½¿ç”¨ç¤ºä¾‹

```cpp
// main.cpp
int main() {
    Logger::Init();  // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    
    // ä½¿ç”¨
    LOG_INFO("RAFT node {} starting...", node_id);
    LOG_DEBUG("Config loaded: heartbeat={}ms, election={}ms", 
              heartbeat_timeout, election_timeout);
    LOG_ERROR("Failed to connect to node {}: {}", peer_id, error_msg);
}

// raft.cpp
void Raft::AppendEntries1(...) {
    LOG_INFO("Node[{}] received AppendEntries from Leader[{}], term={}", 
             m_me, args->leaderid(), args->term());
    
    if (args->term() < m_currentTerm) {
        LOG_WARN("Node[{}] rejected AE: stale term (leader={}, mine={})", 
                 m_me, args->term(), m_currentTerm);
        return;
    }
    
    LOG_DEBUG("Node[{}] processing {} log entries", m_me, args->entries_size());
}
```

#### ä¼˜åŠ¿

âœ… **é«˜æ€§èƒ½**ï¼š
- å¼‚æ­¥æ—¥å¿—ï¼ˆä¸é˜»å¡ä¸»é€»è¾‘ï¼‰
- é›¶æ‹·è´
- æ— é”è®¾è®¡

âœ… **åŠŸèƒ½ä¸°å¯Œ**ï¼š
- æ—¥å¿—çº§åˆ«æ§åˆ¶
- å½©è‰²è¾“å‡º
- æ–‡ä»¶è½®è½¬
- æ”¯æŒå¤šç§ sinkï¼ˆæ–‡ä»¶ã€æ§åˆ¶å°ã€syslogç­‰ï¼‰

âœ… **çº¿ç¨‹å®‰å…¨**ï¼š
- å†…ç½®çº¿ç¨‹å®‰å…¨
- é€‚åˆå¤šçº¿ç¨‹/åç¨‹ç¯å¢ƒ

---

### æ–¹æ¡ˆ3: åç¨‹æ„ŸçŸ¥è°ƒè¯•å·¥å…·ï¼ˆé«˜çº§ï¼‰

#### å®ç°åç¨‹è°ƒè¯•å™¨

```cpp
// fiber_debugger.h
#pragma once
#include <unordered_map>
#include <mutex>
#include <sstream>

class FiberDebugger {
public:
    static FiberDebugger& Instance() {
        static FiberDebugger instance;
        return instance;
    }
    
    // æ³¨å†Œåç¨‹
    void RegisterFiber(uint64_t fiber_id, const std::string& name) {
        std::lock_guard<std::mutex> lock(mutex_);
        fiber_names_[fiber_id] = name;
        fiber_states_[fiber_id] = "READY";
    }
    
    // æ›´æ–°åç¨‹çŠ¶æ€
    void UpdateState(uint64_t fiber_id, const std::string& state) {
        std::lock_guard<std::mutex> lock(mutex_);
        fiber_states_[fiber_id] = state;
    }
    
    // è®°å½•åç¨‹åˆ‡æ¢
    void LogSwitch(uint64_t from_fiber, uint64_t to_fiber) {
        LOG_TRACE("Fiber switch: {} -> {}", 
                  GetFiberName(from_fiber), GetFiberName(to_fiber));
    }
    
    // è·å–æ‰€æœ‰åç¨‹çŠ¶æ€
    std::string DumpAllFibers() {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ostringstream oss;
        oss << "\n=== Fiber States ===\n";
        for (const auto& [id, name] : fiber_names_) {
            oss << "Fiber[" << id << "] '" << name << "': " 
                << fiber_states_[id] << "\n";
        }
        return oss.str();
    }
    
private:
    std::mutex mutex_;
    std::unordered_map<uint64_t, std::string> fiber_names_;
    std::unordered_map<uint64_t, std::string> fiber_states_;
    
    std::string GetFiberName(uint64_t id) {
        auto it = fiber_names_.find(id);
        return it != fiber_names_.end() ? it->second : std::to_string(id);
    }
};

// ä¾¿æ·å®
#define FIBER_DEBUG_REGISTER(name) \
    FiberDebugger::Instance().RegisterFiber(Fiber::GetThis()->getId(), name)

#define FIBER_DEBUG_STATE(state) \
    FiberDebugger::Instance().UpdateState(Fiber::GetThis()->getId(), state)

#define FIBER_DEBUG_DUMP() \
    LOG_DEBUG("{}", FiberDebugger::Instance().DumpAllFibers())
```

#### ä½¿ç”¨ç¤ºä¾‹

```cpp
// raft.cpp
void Raft::leaderHearBeatTicker() {
    FIBER_DEBUG_REGISTER("HeartbeatTicker");
    
    while (true) {
        FIBER_DEBUG_STATE("SLEEPING");
        usleep(HeartBeatTimeout * 1000);
        
        FIBER_DEBUG_STATE("CHECKING");
        if (m_status == Leader) {
            FIBER_DEBUG_STATE("SENDING_HEARTBEAT");
            doHeartbeat();
        }
    }
}

// è¾“å‡ºï¼š
// [TRACE] Fiber switch: HeartbeatTicker -> ApplierTicker
// [DEBUG] === Fiber States ===
//         Fiber[1] 'HeartbeatTicker': SLEEPING
//         Fiber[2] 'ApplierTicker': RUNNING
//         Fiber[3] 'ElectionTicker': SLEEPING
```

---

## ğŸ› ï¸ å®ç”¨è°ƒè¯•æŠ€å·§

### 1. æ¡ä»¶æ—¥å¿—

```cpp
// åªè®°å½•ç‰¹å®šèŠ‚ç‚¹çš„æ—¥å¿—
#define LOG_NODE(node_id, level, fmt, ...) \
    if (m_me == node_id) { \
        LOG_##level(fmt, ##__VA_ARGS__); \
    }

// ä½¿ç”¨
LOG_NODE(0, INFO, "Node 0: AppendEntries received");  // åªæœ‰èŠ‚ç‚¹0è¾“å‡º
```

### 2. æ€§èƒ½æ—¥å¿—

```cpp
// è®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´
class ScopedTimer {
public:
    ScopedTimer(const std::string& name) : name_(name) {
        start_ = std::chrono::high_resolution_clock::now();
    }
    
    ~ScopedTimer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
                            end - start_).count();
        LOG_DEBUG("{} took {} us", name_, duration);
    }
    
private:
    std::string name_;
    std::chrono::time_point<std::chrono::high_resolution_clock> start_;
};

// ä½¿ç”¨
void Raft::AppendEntries1(...) {
    ScopedTimer timer("AppendEntries1");
    // ... å‡½æ•°é€»è¾‘
}  // è‡ªåŠ¨è¾“å‡ºè€—æ—¶
```

### 3. çŠ¶æ€å¿«ç…§

```cpp
// å®šæœŸè¾“å‡ºç³»ç»ŸçŠ¶æ€
void Raft::DumpState() {
    LOG_INFO("=== RAFT State Dump ===");
    LOG_INFO("Node: {}, Term: {}, Status: {}", 
             m_me, m_currentTerm, StatusToString(m_status));
    LOG_INFO("LastLogIndex: {}, CommitIndex: {}, LastApplied: {}", 
             getLastLogIndex(), m_commitIndex, m_lastApplied);
    LOG_INFO("Logs: {} entries", m_logs.size());
    
    if (m_status == Leader) {
        LOG_INFO("NextIndex: [{}]", FormatVector(m_nextIndex));
        LOG_INFO("MatchIndex: [{}]", FormatVector(m_matchIndex));
    }
}

// å®šæ—¶è°ƒç”¨
std::thread([this]() {
    while (true) {
        sleep(10);
        DumpState();
    }
}).detach();
```

### 4. äº‹ä»¶è¿½è¸ª

```cpp
// è¿½è¸ªå…³é”®äº‹ä»¶
enum class Event {
    ELECTION_START,
    ELECTION_TIMEOUT,
    BECOME_LEADER,
    BECOME_FOLLOWER,
    RECEIVE_AE,
    SEND_AE,
    LOG_COMMITTED
};

void LogEvent(Event event, const std::string& details = "") {
    static const char* EventNames[] = {
        "ELECTION_START", "ELECTION_TIMEOUT", "BECOME_LEADER",
        "BECOME_FOLLOWER", "RECEIVE_AE", "SEND_AE", "LOG_COMMITTED"
    };
    
    LOG_INFO("[EVENT] Node[{}] {} {}", m_me, EventNames[(int)event], details);
}

// ä½¿ç”¨
void Raft::doElection() {
    LogEvent(Event::ELECTION_START, format("term={}", m_currentTerm + 1));
    // ...
}
```

---

## ğŸ“Š å¯¹æ¯”ï¼šGDB vs æ—¥å¿—è°ƒè¯•

| ç‰¹æ€§ | GDB | æ—¥å¿—è°ƒè¯• |
|------|-----|---------|
| **é€‚ç”¨åœºæ™¯** | å•çº¿ç¨‹ã€ç®€å•é€»è¾‘ | å¤šçº¿ç¨‹ã€åç¨‹ã€åˆ†å¸ƒå¼ |
| **å®æ—¶æ€§** | å®æ—¶æŸ¥çœ‹å˜é‡ | äº‹ååˆ†æ |
| **å½±å“æ€§èƒ½** | åœæ­¢ç¨‹åºæ‰§è¡Œ | å¼‚æ­¥æ—¥å¿—å½±å“å° |
| **å¹¶å‘è°ƒè¯•** | å›°éš¾ âš ï¸ | å®¹æ˜“ âœ… |
| **åç¨‹è°ƒè¯•** | éå¸¸å›°éš¾ âŒ | é€‚åˆ âœ… |
| **åˆ†å¸ƒå¼è°ƒè¯•** | ä¸æ”¯æŒ âŒ | æ”¯æŒï¼ˆæ—¥å¿—èšåˆï¼‰âœ… |
| **å†å²å›æº¯** | ä¸æ”¯æŒ âŒ | æ”¯æŒï¼ˆæ—¥å¿—æ–‡ä»¶ï¼‰âœ… |
| **å­¦ä¹ æˆæœ¬** | é«˜ | ä½ |

---

## ğŸš€ æ¨èè°ƒè¯•æµç¨‹

### å¼€å‘é˜¶æ®µ

```bash
# 1. å¯ç”¨è¯¦ç»†æ—¥å¿—
# ä¿®æ”¹ config.h
const LogLevel CurrentLogLevel = LogLevel::DEBUG;

# 2. è¿è¡Œæµ‹è¯•
./bin/raftCoreRun -i 0 -f test.conf 2>&1 | tee node0.log

# 3. åˆ†ææ—¥å¿—
grep "ERROR" node0.log
grep "Node\[0\]" node0.log | less
```

### é—®é¢˜å®šä½

```bash
# åœºæ™¯1: æŸ¥æ‰¾ç‰¹å®šèŠ‚ç‚¹çš„é€‰ä¸¾è¿‡ç¨‹
grep "ELECTION" node0.log

# åœºæ™¯2: è¿½è¸ªç‰¹å®š term çš„æ‰€æœ‰æ“ä½œ
grep "term=5" node0.log

# åœºæ™¯3: æŸ¥çœ‹æ—¥å¿—å¤åˆ¶è¿‡ç¨‹
grep "AppendEntries" node*.log | sort

# åœºæ™¯4: åˆ†ææ€§èƒ½é—®é¢˜
grep "took.*ms" node0.log | awk '{print $NF}' | sort -n
```

### ç”Ÿäº§ç¯å¢ƒ

```bash
# 1. åªè®°å½• WARN å’Œ ERROR
const LogLevel CurrentLogLevel = LogLevel::WARN;

# 2. æ—¥å¿—è½®è½¬
# ä½¿ç”¨ spdlog çš„è‡ªåŠ¨è½®è½¬
# æˆ–ä½¿ç”¨ logrotate

# 3. æ—¥å¿—èšåˆ
# ä½¿ç”¨ ELKã€Loki ç­‰å·¥å…·
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. æ—¥å¿—æ ¼å¼è§„èŒƒ

```cpp
// âœ… å¥½çš„æ—¥å¿—
LOG_INFO("Node[{}] AppendEntries: from={}, term={}, entries={}", 
         m_me, leader_id, term, count);

// âŒ ä¸å¥½çš„æ—¥å¿—
LOG_INFO("AE");  // ä¿¡æ¯ä¸è¶³
LOG_INFO("æ”¶åˆ°å¿ƒè·³");  // ç¼ºå°‘å…³é”®ä¿¡æ¯
```

### 2. å…³é”®è·¯å¾„å¿…é¡»è®°å½•

```cpp
// Leaderé€‰ä¸¾
LOG_INFO("Node[{}] starting election, term={}", m_me, new_term);

// æ—¥å¿—å¤åˆ¶
LOG_INFO("Node[{}] sending AE to Node[{}]: prevLog=({},{}), entries={}", 
         m_me, peer, prevLogIndex, prevLogTerm, entries.size());

// çŠ¶æ€å˜æ›´
LOG_INFO("Node[{}] state change: {} -> {}", m_me, old_state, new_state);
```

### 3. é”™è¯¯å¿…é¡»è®°å½•

```cpp
// âœ… è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡
LOG_ERROR("Node[{}] failed to send AE to Node[{}]: {}, retrying...", 
          m_me, peer, error_msg);

// âŒ åªè®°å½•é”™è¯¯
LOG_ERROR("Send failed");
```

---

## ğŸ¯ ç«‹å³è¡ŒåŠ¨

### å¿«é€Ÿæ”¹è¿›å½“å‰çš„ DPrintf

```cpp
// 1. æ·»åŠ åˆ° util.h
#define LOG_DEBUG(fmt, ...) \
    if (Debug) { \
        printf("[DEBUG][%s:%d] ", __FILE__, __LINE__); \
        printf(fmt, ##__VA_ARGS__); \
        printf("\n"); \
    }

// 2. æ›¿æ¢ç°æœ‰çš„ DPrintf
// æ—§: DPrintf("[func-AppendEntries] ...");
// æ–°: LOG_DEBUG("AppendEntries: ...");

// 3. æ·»åŠ æ¡ä»¶ç¼–è¯‘
#ifdef ENABLE_DEBUG_LOG
  #define LOG_DEBUG(fmt, ...) ...
#else
  #define LOG_DEBUG(fmt, ...) do {} while(0)
#endif
```

---

## ğŸ“š æ€»ç»“

1. **ä¸ºä»€ä¹ˆéš¾ç”¨ GDB**ï¼š
   - åç¨‹æ ˆåˆ‡æ¢
   - Hook æœºåˆ¶å¤æ‚
   - å¹¶å‘æ‰§è¡Œéš¾è¿½è¸ª

2. **å½“å‰æ–¹æ¡ˆ**ï¼š
   - DPrintfï¼ˆ86å¤„ä½¿ç”¨ï¼‰
   - ç®€å•ä½†æœ‰æ•ˆ

3. **å»ºè®®æ”¹è¿›**ï¼š
   - çŸ­æœŸï¼šæ”¹è¿› DPrintf æ·»åŠ æ—¥å¿—çº§åˆ«
   - é•¿æœŸï¼šé›†æˆ spdlog
   - é«˜çº§ï¼šå®ç°åç¨‹è°ƒè¯•å™¨

4. **æœ€ä½³å®è·µ**ï¼š
   - å…³é”®è·¯å¾„å¿…é¡»è®°å½•
   - æ—¥å¿—æ ¼å¼è§„èŒƒåŒ–
   - åˆ†çº§æ§åˆ¶è¾“å‡º

**å¯¹äºåç¨‹åŒ–çš„åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œæ—¥å¿—è°ƒè¯•æ¯” GDB æ›´å®ç”¨ï¼** ğŸ“

